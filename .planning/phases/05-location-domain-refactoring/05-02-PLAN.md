---
phase: 05-location-domain-refactoring
plan: 02
type: execute
---

<objective>
Clean up location store interface duplication and ensure consistent authorization.

Purpose: There are 2 LocationStore interfaces with different signatures, and the internal handler bypasses authorization entirely.
Output: Single clean LocationStore interface, consistent authorization across all location access.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-location-domain-refactoring/05-01-SUMMARY.md

# Key files to reference:
@store/location_store.go
@internal/store/interfaces.go
@internal/store/sqlcadapter/location_store.go
@models/location/service/location_service.go
@internal/handlers/location.go

**Prior phase patterns:**
- Service layer handles authorization (location_service.go already does this)
- Store layer is pure data access (no business logic)
- Handlers call service, not store directly

**Issues being addressed:**
- Duplicate LocationStore interface definitions with different method signatures
- internal/handlers/location.go bypasses service layer (no authorization)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Consolidate LocationStore interfaces</name>
  <files>store/location_store.go, internal/store/interfaces.go</files>
  <action>
Compare the two LocationStore interfaces:

**store/location_store.go** (service-oriented):
```go
type LocationStore interface {
    UpdateLocation(ctx, userID, update) (*Location, error)
    GetTripMemberLocations(ctx, tripID) ([]MemberLocation, error)
    GetUserRole(ctx, tripID, userID) (MemberRole, error)
}
```

**internal/store/interfaces.go** (CRUD-oriented):
```go
type LocationStore interface {
    CreateLocation(ctx, location) (string, error)
    GetLocation(ctx, id) (*Location, error)
    UpdateLocation(ctx, id, update) (*Location, error)  // Different signature!
    DeleteLocation(ctx, id) error
    ListTripMemberLocations(ctx, tripID) ([]*MemberLocation, error)
    BeginTx(ctx) (Transaction, error)
}
```

The store/location_store.go interface is used by the service and matches the SQLC adapter implementation.
The internal/store/interfaces.go version is unused or conflicts.

Action:
1. Add Deprecated comment to internal/store/interfaces.go LocationStore:
```go
// Deprecated: LocationStore in internal/store/interfaces.go is deprecated.
// Use store.LocationStore from store/location_store.go instead.
// This interface has different method signatures and is not implemented.
type LocationStore interface {
```

2. Verify that internal/handlers/location.go uses internal/store.LocationStore (it does - line 7 import)
3. Since internal/handlers/location.go is already marked deprecated in Plan 5-01, this interface can stay deprecated

Do NOT delete the interface yet - that could break imports elsewhere. Just mark deprecated.
  </action>
  <verify>
Run `go build ./...` - ensures no compilation errors
Grep for deprecated LocationStore comment
  </verify>
  <done>
- internal/store/interfaces.go LocationStore marked deprecated
- No build errors
  </done>
</task>

<task type="auto">
  <name>Task 2: Add authorization check to internal handler</name>
  <files>internal/handlers/location.go</files>
  <action>
The internal/handlers/location.go handler has a SECURITY GAP:
- GetTripMemberLocations at line 66 accepts tripID from URL but does NO membership check
- Anyone authenticated can query any trip's member locations

Fix by adding authorization check. Two options:

**Option A (Recommended):** Mark entire handler as deprecated and route to service-based handler
Since this handler bypasses the service layer entirely, it's architecturally wrong. Add:
```go
// Deprecated: LocationHandler in internal/handlers is deprecated.
// Use handlers.LocationHandler instead, which properly uses the service layer
// with authorization checks.
type LocationHandler struct {
```

And add TODO comment to GetTripMemberLocations:
```go
// GetTripMemberLocations retrieves all member locations for a trip
// WARNING: This handler bypasses the service layer and has no authorization.
// It should not be used. Use handlers.LocationHandler.GetTripMemberLocationsHandler instead.
// TODO(phase-12): Remove this handler after verifying it's not routed.
func (h *LocationHandler) GetTripMemberLocations(c *gin.Context) {
```

**Option B:** Add authorization directly in handler
This would require injecting TripStore to check membership, which increases coupling.

Go with Option A - deprecate the handler. It's the cleaner architectural choice.

Also verify in router/router.go that this handler is NOT being used for any routes.
  </action>
  <verify>
Run `go build ./...` - no compilation errors
Check router.go does not reference internal/handlers.LocationHandler
  </verify>
  <done>
- internal/handlers/location.go marked as deprecated with security warning
- Router verified to not use this handler (or if used, issue documented)
- Build passes
  </done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `go build ./...` succeeds without errors
- [ ] Duplicate interface marked deprecated
- [ ] Security gap in internal handler documented/addressed
- [ ] No breaking changes to active routes
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- Clear deprecation path for duplicate code
- Security gaps documented
- Phase 5 complete
</success_criteria>

<output>
After completion, create `.planning/phases/05-location-domain-refactoring/05-02-SUMMARY.md` with:

# Phase 5 Plan 2: Store & Authorization Cleanup Summary

**[Substantive one-liner]**

## Accomplishments
- [Key outcomes]

## Files Modified
- [Files and descriptions]

## Decisions Made
- [Any decisions]

## Issues Encountered
- [Problems and resolutions]

## Phase 5 Complete

Ready to proceed to Phase 6: Notification Domain Refactoring.
</output>
