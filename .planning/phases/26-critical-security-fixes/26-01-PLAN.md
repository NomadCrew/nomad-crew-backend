---
phase: 26-critical-security-fixes
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - middleware/rate_limit.go
autonomous: true

must_haves:
  truths:
    - "Rate limiter denies requests (503) when Redis is unavailable"
    - "In-memory fallback activates automatically on Redis failure"
    - "Rate limiting still enforced even when using fallback"
  artifacts:
    - path: "middleware/rate_limit.go"
      provides: "InMemoryRateLimiter struct and AuthRateLimiterWithFallback function"
      contains: "InMemoryRateLimiter"
  key_links:
    - from: "middleware/rate_limit.go"
      to: "Redis client"
      via: "pipe.Exec error handling"
      pattern: "if err != nil.*fallback\\.Allow"
---

<objective>
Implement fail-closed rate limiter with in-memory fallback for SEC-01.

Purpose: The current rate limiter fails open when Redis is unavailable, allowing unlimited brute-force attacks during Redis outages. This is a critical security vulnerability.
Output: Modified `middleware/rate_limit.go` with `InMemoryRateLimiter` struct and `AuthRateLimiterWithFallback` function.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/research/SECURITY.md
@middleware/rate_limit.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add InMemoryRateLimiter struct to rate_limit.go</name>
  <files>middleware/rate_limit.go</files>
  <action>
Add the InMemoryRateLimiter struct and its methods to rate_limit.go:

1. Add imports: `sync` (should already exist via implicit usage check)

2. Add struct definition after the existing imports:
```go
// InMemoryRateLimiter provides a fallback when Redis is unavailable
type InMemoryRateLimiter struct {
    mu        sync.RWMutex
    counts    map[string]*rateLimitEntry
    limit     int
    window    time.Duration
    lastClean time.Time
}

type rateLimitEntry struct {
    count     int
    expiresAt time.Time
}
```

3. Add constructor:
```go
// NewInMemoryRateLimiter creates a new in-memory rate limiter for fallback
func NewInMemoryRateLimiter(limit int, window time.Duration) *InMemoryRateLimiter {
    return &InMemoryRateLimiter{
        counts:    make(map[string]*rateLimitEntry),
        limit:     limit,
        window:    window,
        lastClean: time.Now(),
    }
}
```

4. Add Allow method:
```go
// Allow checks if the request should be allowed and returns (allowed, remaining)
func (l *InMemoryRateLimiter) Allow(key string) (allowed bool, remaining int) {
    l.mu.Lock()
    defer l.mu.Unlock()

    // Periodic cleanup of expired entries
    if time.Since(l.lastClean) > l.window {
        l.cleanup()
        l.lastClean = time.Now()
    }

    now := time.Now()
    entry, exists := l.counts[key]

    if !exists || now.After(entry.expiresAt) {
        // New entry or expired
        l.counts[key] = &rateLimitEntry{
            count:     1,
            expiresAt: now.Add(l.window),
        }
        return true, l.limit - 1
    }

    entry.count++
    if entry.count > l.limit {
        return false, 0
    }
    return true, l.limit - entry.count
}
```

5. Add cleanup method:
```go
func (l *InMemoryRateLimiter) cleanup() {
    now := time.Now()
    for key, entry := range l.counts {
        if now.After(entry.expiresAt) {
            delete(l.counts, key)
        }
    }
}
```
  </action>
  <verify>
Run `go build ./middleware/...` to verify the code compiles without errors.
  </verify>
  <done>
InMemoryRateLimiter struct exists with NewInMemoryRateLimiter constructor and Allow method.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create AuthRateLimiterWithFallback function</name>
  <files>middleware/rate_limit.go</files>
  <action>
Add the new AuthRateLimiterWithFallback function that uses Redis with in-memory fallback:

```go
// AuthRateLimiterWithFallback creates a rate limiter middleware that uses Redis
// with an in-memory fallback when Redis is unavailable.
// SECURITY: This ensures rate limiting is ALWAYS enforced (fail-closed behavior).
func AuthRateLimiterWithFallback(
    redisClient *redis.Client,
    fallback *InMemoryRateLimiter,
    requestsPerMinute int,
    window time.Duration,
) gin.HandlerFunc {
    return func(c *gin.Context) {
        ip := getClientIP(c)
        key := fmt.Sprintf("ratelimit:auth:%s", ip)

        // Try Redis first
        pipe := redisClient.TxPipeline()
        incr := pipe.Incr(c.Request.Context(), key)
        pipe.Expire(c.Request.Context(), key, window)

        _, err := pipe.Exec(c.Request.Context())
        if err != nil {
            // Redis failed - use in-memory fallback (STILL ENFORCES LIMITS)
            // Log at warn level since this is degraded but functional
            allowed, remaining := fallback.Allow(key)
            if !allowed {
                c.Header("X-RateLimit-Limit", fmt.Sprintf("%d", requestsPerMinute))
                c.Header("X-RateLimit-Remaining", "0")
                c.Header("Retry-After", fmt.Sprintf("%d", int(window.Seconds())))
                c.Header("X-RateLimit-Mode", "fallback")
                _ = c.Error(apperrors.RateLimitExceeded(
                    "Too many requests. Please try again later.",
                    int(window.Seconds()),
                ))
                c.Abort()
                return
            }

            c.Header("X-RateLimit-Limit", fmt.Sprintf("%d", requestsPerMinute))
            c.Header("X-RateLimit-Remaining", fmt.Sprintf("%d", remaining))
            c.Header("X-RateLimit-Mode", "fallback")
            c.Next()
            return
        }

        // Redis succeeded - normal flow
        count := incr.Val()
        if count > int64(requestsPerMinute) {
            ttl, err := redisClient.TTL(c.Request.Context(), key).Result()
            if err != nil || ttl < 0 {
                ttl = window
            }

            c.Header("X-RateLimit-Limit", fmt.Sprintf("%d", requestsPerMinute))
            c.Header("X-RateLimit-Remaining", "0")
            c.Header("X-RateLimit-Reset", fmt.Sprintf("%d", time.Now().Add(ttl).Unix()))
            c.Header("Retry-After", fmt.Sprintf("%d", int(ttl.Seconds())))

            _ = c.Error(apperrors.RateLimitExceeded("Too many requests. Please try again later.", int(ttl.Seconds())))
            c.Abort()
            return
        }

        // Add rate limit headers for successful requests
        remaining := requestsPerMinute - int(count)
        if remaining < 0 {
            remaining = 0
        }

        c.Header("X-RateLimit-Limit", fmt.Sprintf("%d", requestsPerMinute))
        c.Header("X-RateLimit-Remaining", fmt.Sprintf("%d", remaining))
        c.Header("X-RateLimit-Reset", fmt.Sprintf("%d", time.Now().Add(window).Unix()))

        c.Next()
    }
}
```

Note: Keep the existing `AuthRateLimiter` function for now - we will update the router to use the new function in a separate task. This ensures backward compatibility during the transition.
  </action>
  <verify>
Run `go build ./middleware/...` to verify the code compiles without errors.
  </verify>
  <done>
AuthRateLimiterWithFallback function exists and compiles successfully.
  </done>
</task>

<task type="auto">
  <name>Task 3: Update router to use AuthRateLimiterWithFallback</name>
  <files>router/router.go</files>
  <action>
Update the router to create and use the fallback-enabled rate limiter:

1. In SetupRouter function, create the fallback limiter before the rate limiter middleware:

Find this section (around line 130-136):
```go
// Create rate limiter for auth endpoints
authRateLimiter := middleware.AuthRateLimiter(
    deps.RedisClient,
    deps.Config.RateLimit.AuthRequestsPerMinute,
    time.Duration(deps.Config.RateLimit.WindowSeconds)*time.Second,
)
```

Replace with:
```go
// Create fallback limiter for when Redis is unavailable
fallbackLimiter := middleware.NewInMemoryRateLimiter(
    deps.Config.RateLimit.AuthRequestsPerMinute,
    time.Duration(deps.Config.RateLimit.WindowSeconds)*time.Second,
)

// Create rate limiter for auth endpoints with fallback
// SECURITY: Uses fail-closed behavior - rate limiting is always enforced
authRateLimiter := middleware.AuthRateLimiterWithFallback(
    deps.RedisClient,
    fallbackLimiter,
    deps.Config.RateLimit.AuthRequestsPerMinute,
    time.Duration(deps.Config.RateLimit.WindowSeconds)*time.Second,
)
```

The rest of the router code remains unchanged - the authRateLimiter is still applied to the same endpoints.
  </action>
  <verify>
Run `go build ./...` to verify the entire project compiles without errors.
  </verify>
  <done>
Router uses AuthRateLimiterWithFallback with InMemoryRateLimiter fallback.
  </done>
</task>

</tasks>

<verification>
1. `go build ./...` passes without errors
2. `go vet ./middleware/...` passes without warnings
3. Review rate_limit.go to confirm:
   - InMemoryRateLimiter struct exists with Allow method
   - AuthRateLimiterWithFallback function exists
   - On Redis error, fallback.Allow is called instead of c.Next()
4. Review router/router.go to confirm:
   - fallbackLimiter is created
   - AuthRateLimiterWithFallback is used instead of AuthRateLimiter
</verification>

<success_criteria>
- Rate limiter middleware uses in-memory fallback when Redis fails
- Rate limiting is enforced even during Redis outages (fail-closed)
- X-RateLimit-Mode: fallback header indicates fallback mode
- Code compiles and passes vet checks
</success_criteria>

<output>
After completion, create `.planning/phases/26-critical-security-fixes/26-01-SUMMARY.md`
</output>
