---
phase: 28-goroutine-management
plan: 02
type: execute
wave: 2
depends_on: ["28-01"]
files_modified:
  - services/notification_facade_service.go
  - main.go
autonomous: true

must_haves:
  truths:
    - "SendTripUpdateAsync submits job to worker pool instead of spawning goroutine"
    - "SendChatMessageAsync submits job to worker pool instead of spawning goroutine"
    - "Worker pool is initialized at startup and included in shutdown sequence"
    - "Shutdown drains notification jobs before stopping event service"
    - "No goroutine leaks after graceful shutdown"
  artifacts:
    - path: "services/notification_facade_service.go"
      provides: "Refactored async methods using worker pool"
      contains: "workerPool.Submit"
    - path: "main.go"
      provides: "Worker pool lifecycle management"
      contains: ["NewWorkerPool", "workerPool.Start", "workerPool.Shutdown"]
  key_links:
    - from: "services/notification_facade_service.go"
      to: "services/notification_worker_pool.go"
      via: "WorkerPool.Submit"
      pattern: "workerPool\\.Submit"
    - from: "main.go"
      to: "services/notification_worker_pool.go"
      via: "lifecycle management"
      pattern: "(NewWorkerPool|Start|Shutdown)"
---

<objective>
Refactor NotificationFacadeService to use worker pool and integrate shutdown sequence.

Purpose: Replace fire-and-forget goroutines with tracked, bounded worker pool jobs that can be gracefully drained during shutdown.

Output: Refactored `notification_facade_service.go` and updated `main.go` with worker pool lifecycle.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/28-goroutine-management/28-RESEARCH.md
@.planning/phases/28-goroutine-management/28-01-SUMMARY.md

# Files to modify:
@services/notification_facade_service.go
@main.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Refactor NotificationFacadeService to use worker pool</name>
  <files>services/notification_facade_service.go</files>
  <action>
Modify NotificationFacadeService to accept a WorkerPool and use it for async operations.

Changes:

1. Add workerPool field to struct:
```go
type NotificationFacadeService struct {
    client     *notification.Client
    enabled    bool
    logger     *zap.SugaredLogger
    workerPool *WorkerPool  // NEW
}
```

2. Update constructor to accept optional worker pool:
```go
// NewNotificationFacadeService creates a new notification service.
// The workerPool parameter is optional - if nil, async methods will use fire-and-forget goroutines (not recommended).
func NewNotificationFacadeService(cfg *config.NotificationConfig, workerPool *WorkerPool) *NotificationFacadeService {
    log := logger.GetLogger()

    if !cfg.Enabled {
        log.Info("Notification service disabled")
        return &NotificationFacadeService{
            enabled:    false,
            logger:     log,
            workerPool: workerPool,
        }
    }

    // Create HTTP client with custom timeout
    httpClient := &http.Client{
        Timeout: time.Duration(cfg.TimeoutSeconds) * time.Second,
    }

    client := notification.NewClient(
        cfg.APIUrl,
        cfg.APIKey,
        notification.WithHTTPClient(httpClient),
    )

    return &NotificationFacadeService{
        client:     client,
        enabled:    true,
        logger:     log,
        workerPool: workerPool,
    }
}
```

3. Refactor SendTripUpdateAsync to use worker pool:
```go
// SendTripUpdateAsync sends trip update notifications asynchronously via worker pool.
func (s *NotificationFacadeService) SendTripUpdateAsync(ctx context.Context, userIDs []string, data notification.TripUpdateData, priority notification.Priority) {
    if !s.enabled {
        return
    }

    // Use worker pool if available
    if s.workerPool != nil {
        s.workerPool.Submit(Job{
            Name: fmt.Sprintf("trip-update-%s", data.TripID),
            Execute: func(jobCtx context.Context) error {
                return s.SendTripUpdate(jobCtx, userIDs, data, priority)
            },
        })
        return
    }

    // Fallback to legacy fire-and-forget (not recommended)
    s.logger.Warn("Worker pool not configured, using fire-and-forget goroutine for async notification")
    go func() {
        asyncCtx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
        defer cancel()

        if err := s.SendTripUpdate(asyncCtx, userIDs, data, priority); err != nil {
            s.logger.Error("Async trip update notification failed", "error", err)
        }
    }()
}
```

4. Refactor SendChatMessageAsync similarly:
```go
// SendChatMessageAsync sends chat message notifications asynchronously via worker pool.
func (s *NotificationFacadeService) SendChatMessageAsync(ctx context.Context, recipientIDs []string, data notification.ChatMessageData) {
    if !s.enabled {
        return
    }

    // Use worker pool if available
    if s.workerPool != nil {
        s.workerPool.Submit(Job{
            Name: fmt.Sprintf("chat-message-%s", data.ChatID),
            Execute: func(jobCtx context.Context) error {
                return s.SendChatMessage(jobCtx, recipientIDs, data)
            },
        })
        return
    }

    // Fallback to legacy fire-and-forget (not recommended)
    s.logger.Warn("Worker pool not configured, using fire-and-forget goroutine for async notification")
    go func() {
        asyncCtx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
        defer cancel()

        if err := s.SendChatMessage(asyncCtx, recipientIDs, data); err != nil {
            s.logger.Error("Async chat message notification failed", "error", err)
        }
    }()
}
```

Note: Add `"fmt"` to imports if not already present.

Key design decisions:
- Backward compatible: nil workerPool falls back to old behavior with warning
- Job names include context (trip ID, chat ID) for debugging
- Uses worker pool's internal context timeout (30s) instead of creating new one
  </action>
  <verify>
Run `go build ./services/notification_facade_service.go` to verify compilation.
Run `go vet ./services/...` to check for issues.
  </verify>
  <done>
NotificationFacadeService has workerPool field.
NewNotificationFacadeService accepts *WorkerPool parameter.
SendTripUpdateAsync uses workerPool.Submit when pool is available.
SendChatMessageAsync uses workerPool.Submit when pool is available.
Fallback to fire-and-forget with warning when pool is nil.
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate worker pool into main.go lifecycle</name>
  <files>main.go</files>
  <action>
Update main.go to create, start, and shutdown the worker pool.

Changes:

1. Add import (if not already present, services is already imported):
No new imports needed - services package already imported.

2. After config loading and before service initialization (around line 150), create and start worker pool:
```go
// Initialize notification worker pool
notificationWorkerPool := services.NewWorkerPool(cfg.WorkerPool)
notificationWorkerPool.Start()
log.Infow("Notification worker pool started",
    "maxWorkers", cfg.WorkerPool.MaxWorkers,
    "queueSize", cfg.WorkerPool.QueueSize)
```

3. Update NotificationFacadeService initialization (around line 209) to pass worker pool:
```go
// Initialize notification facade service (for chat and other notifications)
notificationFacadeService := services.NewNotificationFacadeService(&cfg.Notification, notificationWorkerPool)
log.Infow("Notification facade service initialized", "enabled", notificationFacadeService.IsEnabled())
```

4. Update shutdown sequence (around line 314-336) to shutdown worker pool FIRST, before WebSocket hub:
```go
// Wait for shutdown signal and then gracefully shut down
<-shutdownCtx.Done()
log.Info("Shutting down server...")

// Create a deadline to wait for current operations to complete
ctx, cancel := context.WithTimeout(context.Background(), time.Duration(cfg.WorkerPool.ShutdownTimeoutSeconds)*time.Second)
defer cancel()

// Shutdown notification worker pool first to drain pending notifications
log.Info("Shutting down notification worker pool...")
if err := notificationWorkerPool.Shutdown(ctx); err != nil {
    log.Errorw("Error during notification worker pool shutdown", "error", err)
}

// Shutdown WebSocket hub to close all connections gracefully
log.Info("Shutting down WebSocket hub...")
if err := wsHub.Shutdown(ctx); err != nil {
    log.Errorw("Error during WebSocket hub shutdown", "error", err)
}

// Shutdown event service to stop processing new events
log.Info("Shutting down event service...")
if err := eventService.Shutdown(ctx); err != nil {
    log.Errorw("Error during event service shutdown", "error", err)
}

// Then shutdown HTTP server
if err := srv.Shutdown(ctx); err != nil {
    log.Fatalw("Server forced to shutdown", "error", err)
}

log.Info("Server has been gracefully shut down")
```

Shutdown order rationale (from RESEARCH.md):
1. Notification worker pool - drain pending notification jobs
2. WebSocket hub - close client connections
3. Event service - stop Redis subscriptions
4. HTTP server - stop accepting new requests

This ensures notifications triggered by final HTTP requests have a chance to be sent.
  </action>
  <verify>
Run `go build .` to verify main.go compiles.
Run `go vet .` to check for issues.
  </verify>
  <done>
notificationWorkerPool created with cfg.WorkerPool config.
notificationWorkerPool.Start() called after creation.
NewNotificationFacadeService receives notificationWorkerPool as second parameter.
Shutdown sequence: worker pool -> WebSocket hub -> event service -> HTTP server.
Shutdown timeout uses cfg.WorkerPool.ShutdownTimeoutSeconds.
  </done>
</task>

<task type="auto">
  <name>Task 3: Verify graceful shutdown behavior</name>
  <files>N/A</files>
  <action>
Verify the implementation works correctly by:

1. Build and check for compilation errors:
```bash
go build .
```

2. Check for vet issues:
```bash
go vet ./...
```

3. Run existing tests to ensure no regressions:
```bash
go test ./services/... -v
go test ./config/... -v
```

4. Verify worker pool metrics are registered (check for duplicate registration panics):
```bash
go test ./services/notification_worker_pool_test.go -v
```

5. Check goroutine tracking pattern is correct by reviewing:
- wg.Add(1) is called BEFORE go func()
- defer wg.Done() is at START of goroutine
- wg.Wait() is called with select for timeout

6. Document the final shutdown sequence in logs:
```
INFO  Shutting down server...
INFO  Shutting down notification worker pool...
DEBUG Worker stopping (context cancelled), workerId=0
DEBUG Worker stopping (context cancelled), workerId=1
...
INFO  Worker pool shutdown complete - all workers finished
INFO  Shutting down WebSocket hub...
INFO  WebSocket hub shutdown complete
INFO  Shutting down event service...
INFO  All subscription goroutines finished. RedisPublisher shutdown complete.
INFO  Server has been gracefully shut down
```
  </action>
  <verify>
`go build .` succeeds.
`go vet ./...` reports no issues.
`go test ./services/... -v` passes.
`go test ./config/... -v` passes.
No duplicate metric registration panics.
  </verify>
  <done>
Build succeeds without errors.
Vet reports no issues.
All existing tests pass.
Worker pool tests pass (from Plan 01).
No goroutine leaks in worker pool implementation.
  </done>
</task>

</tasks>

<verification>
1. `go build .` - Full application compiles
2. `go vet ./...` - No issues
3. `go test ./services/... -v` - All service tests pass
4. `go test ./config/... -v` - All config tests pass
5. Check logs show correct shutdown sequence when running locally with SIGTERM
</verification>

<success_criteria>
1. NotificationFacadeService uses worker pool for SendTripUpdateAsync and SendChatMessageAsync
2. Worker pool is created and started in main.go with config values
3. Shutdown sequence is: worker pool -> WebSocket hub -> event service -> HTTP server
4. All existing tests pass
5. No compilation errors or vet warnings
6. SEC-03 closed: Notification service uses bounded worker pool instead of unbounded goroutines
7. SEC-04 closed: Background tasks tracked and awaited during graceful shutdown
</success_criteria>

<output>
After completion, create `.planning/phases/28-goroutine-management/28-02-SUMMARY.md`
</output>
