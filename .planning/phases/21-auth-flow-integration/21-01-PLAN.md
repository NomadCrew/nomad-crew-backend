---
phase: 21-auth-flow-integration
plan: 01
type: execute
---

<objective>
Verify Supabase auth works end-to-end with mobile app, fix any issues discovered.

Purpose: Ensure the mobile app can authenticate users and make API calls to the backend correctly.
Output: Verified auth flow with documented test results and any fixes applied.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-phase.md
@~/.claude/get-shit-done/templates/summary.md
@~/.claude/get-shit-done/references/checkpoints.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

**Backend auth implementation:**
@middleware/auth.go - AuthMiddleware with JWT validation
@middleware/jwt_validator.go - JWKS and HS256 JWT validation

**Frontend auth implementation:**
@../nomad-crew-frontend/src/features/auth/store.ts - Zustand auth store
@../nomad-crew-frontend/src/features/auth/service.ts - Supabase client

**Key patterns:**
- Backend uses JWKS validation (Supabase new API keys) with HS256 fallback
- Frontend stores JWT in SecureStore, uses Supabase SDK for token refresh
- Admin status extracted from `app_metadata.is_admin` claim
- User ID is Supabase UUID, resolved to internal user via GetUserBySupabaseID
- Simulator bypass available in development mode (SERVER_ENVIRONMENT=development)

**Production:**
- API: https://api.nomadcrew.uk
- Routes at /v1/... (not /api/v1/...)
</context>

<tasks>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Auth flow test scenarios</what-built>
  <how-to-verify>
    **Pre-requisites:**
    1. Start backend: `be-run` (or `go run main.go`)
    2. Start frontend: `android-dev` (starts emulator + Metro)
    3. Have a test Supabase account ready

    **Test Scenario 1: Fresh Login**
    1. Open app on emulator (should show login/register screen)
    2. Log in with valid Supabase credentials
    3. Verify: App navigates to main screen
    4. Check backend logs for: "Authentication successful" with userID
    5. Check: Token stored correctly (app doesn't prompt re-login on restart)

    **Test Scenario 2: Token Refresh**
    1. With app logged in, wait for token to approach expiry (or force refresh)
    2. Make an API call (e.g., fetch trips)
    3. Verify: API call succeeds without logout
    4. Check backend logs for successful validation

    **Test Scenario 3: Protected Endpoints**
    1. Try to access /v1/trips endpoint
    2. Verify: Returns trips for authenticated user
    3. Try to access without token (e.g., curl without auth header)
    4. Verify: Returns 401 Unauthorized

    **Test Scenario 4: Admin Role Detection (if applicable)**
    1. If test user has `app_metadata.is_admin: true` in Supabase
    2. Make an API call
    3. Check backend logs for: "isAdmin": true

    **Test Scenario 5: Logout Flow**
    1. Log out from the app
    2. Verify: App returns to login screen
    3. Verify: Backend resources are cleaned up (push token deregistered)
    4. Restart app: Should NOT auto-login

    **Document any issues found:**
    - Note exact error messages
    - Note which scenario failed
    - Note frontend/backend logs
  </how-to-verify>
  <resume-signal>Type "all-pass" if all scenarios pass, or describe issues found with scenario number</resume-signal>
</task>

<task type="auto">
  <name>Fix discovered auth issues</name>
  <files>Depends on issues found - likely middleware/*.go or frontend auth files</files>
  <action>
    Based on issues discovered in the verification task:

    **Common issues to check/fix:**
    1. JWT token format issues - Ensure frontend sends Bearer token correctly
    2. JWKS cache issues - Check if JWKS is being fetched and cached properly
    3. User resolution issues - Ensure GetUserBySupabaseID finds the user
    4. Token expiry handling - Check refresh flow works correctly
    5. CORS issues - Ensure OPTIONS requests are handled

    **If no issues found:**
    - Document that auth flow is working correctly
    - Note any edge cases tested
    - Confirm production readiness

    **If issues found:**
    - Implement minimal fixes following established patterns
    - Use c.Error() + c.Abort() for error handling
    - Log with structured logging (logger.Infow, logger.Warnw, logger.Errorw)
    - Do NOT change API contracts
  </action>
  <verify>
    If fixes made:
    - go build ./... succeeds
    - Re-run failed test scenarios
    - All scenarios pass

    If no fixes needed:
    - Document verification results
  </verify>
  <done>
    Either:
    - All auth test scenarios pass (original or after fixes)
    - Issues documented with fix plan for future phase
  </done>
</task>

</tasks>

<verification>
Before declaring phase complete:
- [ ] All 5 test scenarios executed
- [ ] Any discovered issues either fixed or documented
- [ ] go build ./... passes (if changes made)
- [ ] Backend logs show successful auth for valid tokens
- [ ] Backend logs show 401 for invalid/missing tokens
</verification>

<success_criteria>

- All auth test scenarios documented and executed
- JWT token flow verified from mobile to backend
- Refresh token handling verified
- Admin role detection verified (if test user has admin flag)
- Any blocking issues fixed
- Non-blocking issues documented for future phases
</success_criteria>

<output>
After completion, create `.planning/phases/21-auth-flow-integration/21-01-SUMMARY.md`:

# Phase 21 Plan 01: Auth Flow Integration Summary

**[Status: Pass/Fail with summary]**

## Test Results

| Scenario | Status | Notes |
|----------|--------|-------|
| 1. Fresh Login | Pass/Fail | ... |
| 2. Token Refresh | Pass/Fail | ... |
| 3. Protected Endpoints | Pass/Fail | ... |
| 4. Admin Detection | Pass/Fail/N/A | ... |
| 5. Logout Flow | Pass/Fail | ... |

## Issues Found

[List any issues discovered during testing]

## Fixes Applied

[List any fixes made, or "None required"]

## Files Modified

[List files changed, or "None"]

## Next Phase Readiness

[Ready for Phase 22: API Gap Analysis / Blocked by X]
</output>
