# Phase 11: Event System and WebSocket Refactoring - Plan 01

## Event Publishing Pattern Standardization

**Created:** 2026-01-12
**Status:** Ready for Execution
**Estimated Tasks:** 2

---

## Context

### Analysis Summary

The event system and websocket code is already well-structured with:
- Clean architecture: Service > Router > Publisher
- Prometheus metrics for observability
- Proper error handling with context
- WebSocket hub with proper connection lifecycle management
- No TODO/FIXME comments

| Component | Status |
|-----------|--------|
| `internal/events/service.go` | ✅ Clean - handler registration, publish/subscribe |
| `internal/events/router.go` | ✅ Clean - event routing with metrics |
| `internal/events/redis_publisher.go` | ✅ Clean - Redis pub/sub with proper shutdown |
| `internal/events/publisher.go` | ✅ Clean - standardized PublishEventWithContext helper |
| `internal/websocket/hub.go` | ✅ Clean - connection management |
| `internal/websocket/handler.go` | ✅ Clean - WebSocket lifecycle |

### Pattern Consistency

Most services use `events.PublishEventWithContext()` for event publishing:
- `location_service.go` ✅
- `trip_service.go` ✅
- `member_service.go` ✅
- `invitation_service.go` ✅
- `weather_service.go` ✅
- `notification_service.go` ✅
- `event_emitter.go` ✅
- **`chat_service.go`** ❌ Manually builds Event struct

---

## Objective

Standardize event publishing in `chat_service.go` to use `PublishEventWithContext` for consistency with the rest of the codebase.

---

## Tasks

### Task 1: Standardize chat_service.go event publishing

**File:** `models/chat/service/chat_service.go`

**Current pattern (lines ~920-951):**
```go
func (s *ChatService) publishChatEvent(ctx context.Context, tripID, userID, eventType string, eventData interface{}) {
    payload, err := json.Marshal(eventData)
    if err != nil {
        s.log.Errorw("Failed to marshal event data", "error", err)
        return
    }

    chatEventType := "chat." + eventType

    event := types.Event{
        BaseEvent: types.BaseEvent{
            ID:        utils.GenerateEventID(),
            Type:      types.EventType(chatEventType),
            TripID:    tripID,
            UserID:    userID,
            Timestamp: time.Now(),
            Version:   1,
        },
        Metadata: types.EventMetadata{
            Source: "chat-service",
        },
        Payload: payload,
    }

    if err := s.eventService.Publish(ctx, tripID, event); err != nil {
        s.log.Errorw("Failed to publish chat event", "error", err, "eventType", chatEventType)
    }
}
```

**New pattern:**
```go
func (s *ChatService) publishChatEvent(ctx context.Context, tripID, userID, eventType string, eventData map[string]interface{}) {
    chatEventType := "chat." + eventType

    if err := events.PublishEventWithContext(
        s.eventPublisher,
        ctx,
        chatEventType,
        tripID,
        userID,
        eventData,
        "chat-service",
    ); err != nil {
        s.log.Errorw("Failed to publish chat event", "error", err, "eventType", chatEventType)
    }
}
```

**Changes required:**
1. Change `eventData interface{}` parameter to `eventData map[string]interface{}`
2. Use `events.PublishEventWithContext` instead of manual Event struct
3. Ensure `s.eventPublisher` is available (check if it implements `types.EventPublisher`)
4. Update callers if needed to pass `map[string]interface{}` instead of struct

**Note:** Need to verify ChatService has access to EventPublisher interface.

---

### Task 2: Verify and document event publisher interface

**Action:** Verify that ChatService has proper access to EventPublisher.

If ChatService uses `eventService` (which is `*events.Service`), we need to either:
- A) Use `s.eventService` directly as EventPublisher (it implements the interface)
- B) Add an eventPublisher field to ChatService

**Verification:**
- [ ] Check ChatService struct fields
- [ ] Ensure events.Service implements types.EventPublisher
- [ ] Update if needed

---

## Files Modified

| File | Action |
|------|--------|
| `models/chat/service/chat_service.go` | Standardize event publishing |

---

## Success Criteria

- [ ] chat_service.go uses PublishEventWithContext
- [ ] All event publishing follows consistent pattern
- [ ] `go build ./...` passes
- [ ] Existing tests pass

---

*Phase: 11-event-websocket-refactoring*
*Plan: 11-01*
*Created: 2026-01-12*
