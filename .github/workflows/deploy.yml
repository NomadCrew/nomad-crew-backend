name: Build and Deploy to AWS

on:
  push:
    branches:
      - main
  workflow_dispatch:  # Allow manual triggering

env:
  AWS_REGION: us-east-2
  ECR_REPOSITORY: nomadcrew
  TF_VERSION: 1.5.7
  TG_VERSION: 0.51.1

jobs:
  build-and-push:
    name: Build and Push Docker Image
    runs-on: ubuntu-latest
    outputs:
      image_tag: ${{ steps.build-image.outputs.image_tag }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v1

      - name: Build, tag, and push image to Amazon ECR
        id: build-image
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        run: |
          # Build a docker image and push it to ECR
          IMAGE_TAG=$(echo $GITHUB_SHA | head -c7)
          REPOSITORY_URI=$ECR_REGISTRY/$ECR_REPOSITORY
          
          docker build -t $REPOSITORY_URI:$IMAGE_TAG -t $REPOSITORY_URI:latest .
          docker push $REPOSITORY_URI:$IMAGE_TAG
          docker push $REPOSITORY_URI:latest
          
          echo "image_tag=$IMAGE_TAG" >> $GITHUB_OUTPUT
          echo "::set-output name=image_tag::$IMAGE_TAG"

  deploy-infrastructure:
    name: Deploy Infrastructure
    needs: build-and-push
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_version: ${{ env.TF_VERSION }}

      - name: Install Terragrunt
        run: |
          wget -O terragrunt https://github.com/gruntwork-io/terragrunt/releases/download/v${{ env.TG_VERSION }}/terragrunt_linux_amd64
          chmod +x terragrunt
          sudo mv terragrunt /usr/local/bin/terragrunt

      - name: Create S3 bucket for Terraform state if it doesn't exist
        run: |
          aws s3api head-bucket --bucket nomadcrew-terraform-state 2>/dev/null || \
          aws s3api create-bucket --bucket nomadcrew-terraform-state --region ${{ env.AWS_REGION }}
          
          aws s3api put-bucket-versioning \
            --bucket nomadcrew-terraform-state \
            --versioning-configuration Status=Enabled
          
          aws s3api put-bucket-encryption \
            --bucket nomadcrew-terraform-state \
            --server-side-encryption-configuration '{"Rules": [{"ApplyServerSideEncryptionByDefault": {"SSEAlgorithm": "AES256"}}]}'

      - name: Create DynamoDB table for Terraform locks if it doesn't exist
        run: |
          aws dynamodb describe-table --table-name nomadcrew-terraform-locks 2>/dev/null || \
          aws dynamodb create-table \
            --table-name nomadcrew-terraform-locks \
            --attribute-definitions AttributeName=LockID,AttributeType=S \
            --key-schema AttributeName=LockID,KeyType=HASH \
            --billing-mode PAY_PER_REQUEST

      - name: Deploy with Terragrunt
        working-directory: ./deployment/environments/prod
        env:
          TF_VAR_db_password: ${{ secrets.DB_PASSWORD }}
          TF_VAR_route53_zone_id: ${{ secrets.ROUTE53_ZONE_ID }}
          TF_VAR_certificate_arn: ${{ secrets.CERTIFICATE_ARN }}
          TF_VAR_key_name: ${{ secrets.SSH_KEY_NAME }}
          TF_VAR_ami_id: ${{ secrets.CUSTOM_AMI_ID || 'ami-0230bd60aa48260c6' }}
          TF_VAR_image_tag: ${{ needs.build-and-push.outputs.image_tag }}
        run: |
          terragrunt init
          terragrunt validate
          terragrunt plan
          terragrunt apply -auto-approve

  update-application:
    name: Update Application
    needs: [build-and-push, deploy-infrastructure]
    runs-on: ubuntu-latest
    
    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Get Auto Scaling Group name
        id: get-asg
        run: |
          ASG_NAME=$(aws autoscaling describe-auto-scaling-groups --query "AutoScalingGroups[?contains(Tags[?Key=='Project'].Value, 'NomadCrew') && contains(Tags[?Key=='Environment'].Value, 'prod')].AutoScalingGroupName" --output text)
          echo "asg_name=$ASG_NAME" >> $GITHUB_OUTPUT

      - name: Start instance refresh
        if: steps.get-asg.outputs.asg_name != ''
        run: |
          aws autoscaling start-instance-refresh \
            --auto-scaling-group-name ${{ steps.get-asg.outputs.asg_name }} \
            --preferences '{"MinHealthyPercentage": 90, "InstanceWarmup": 300}'

  verify-deployment:
    name: Verify Deployment
    needs: [update-application]
    runs-on: ubuntu-latest
    
    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Check application health
        run: |
          # Get the ALB DNS name
          ALB_DNS=$(aws elbv2 describe-load-balancers --query "LoadBalancers[?contains(LoadBalancerName, 'nomadcrew')].DNSName" --output text)
          
          # Wait for the application to be healthy
          echo "Waiting for application to be healthy at https://$ALB_DNS/health/liveness"
          
          # Try up to 10 times with 30 second intervals
          for i in {1..10}; do
            HTTP_STATUS=$(curl -s -o /dev/null -w "%{http_code}" https://$ALB_DNS/health/liveness)
            
            if [ "$HTTP_STATUS" -eq 200 ]; then
              echo "Application is healthy!"
              exit 0
            else
              echo "Attempt $i: Application is not healthy yet. Status: $HTTP_STATUS"
              sleep 30
            fi
          done
          
          echo "Application failed to become healthy after multiple attempts."
          exit 1 