// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: locations.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createLocation = `-- name: CreateLocation :one

INSERT INTO locations (
    trip_id, user_id, latitude, longitude, accuracy, timestamp,
    location_name, location_type, notes, status,
    is_sharing_enabled, sharing_expires_at, privacy
)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13)
RETURNING id
`

type CreateLocationParams struct {
	TripID           string             `db:"trip_id" json:"trip_id"`
	UserID           string             `db:"user_id" json:"user_id"`
	Latitude         float64            `db:"latitude" json:"latitude"`
	Longitude        float64            `db:"longitude" json:"longitude"`
	Accuracy         *float64           `db:"accuracy" json:"accuracy"`
	Timestamp        pgtype.Timestamptz `db:"timestamp" json:"timestamp"`
	LocationName     *string            `db:"location_name" json:"location_name"`
	LocationType     *string            `db:"location_type" json:"location_type"`
	Notes            *string            `db:"notes" json:"notes"`
	Status           *string            `db:"status" json:"status"`
	IsSharingEnabled *bool              `db:"is_sharing_enabled" json:"is_sharing_enabled"`
	SharingExpiresAt pgtype.Timestamptz `db:"sharing_expires_at" json:"sharing_expires_at"`
	Privacy          LocationPrivacy    `db:"privacy" json:"privacy"`
}

// Locations Operations
func (q *Queries) CreateLocation(ctx context.Context, arg CreateLocationParams) (string, error) {
	row := q.db.QueryRow(ctx, createLocation,
		arg.TripID,
		arg.UserID,
		arg.Latitude,
		arg.Longitude,
		arg.Accuracy,
		arg.Timestamp,
		arg.LocationName,
		arg.LocationType,
		arg.Notes,
		arg.Status,
		arg.IsSharingEnabled,
		arg.SharingExpiresAt,
		arg.Privacy,
	)
	var id string
	err := row.Scan(&id)
	return id, err
}

const disableExpiredSharing = `-- name: DisableExpiredSharing :exec
UPDATE locations
SET
    is_sharing_enabled = false,
    updated_at = CURRENT_TIMESTAMP
WHERE is_sharing_enabled = true
    AND sharing_expires_at IS NOT NULL
    AND sharing_expires_at <= CURRENT_TIMESTAMP
    AND deleted_at IS NULL
`

// Disable location sharing that has expired
func (q *Queries) DisableExpiredSharing(ctx context.Context) error {
	_, err := q.db.Exec(ctx, disableExpiredSharing)
	return err
}

const getLocation = `-- name: GetLocation :one
SELECT
    id, trip_id, user_id, latitude, longitude, accuracy, timestamp,
    COALESCE(location_name, '') as location_name,
    COALESCE(location_type, '') as location_type,
    COALESCE(notes, '') as notes,
    COALESCE(status, 'planned') as status,
    is_sharing_enabled, sharing_expires_at, privacy,
    created_at, updated_at
FROM locations
WHERE id = $1 AND deleted_at IS NULL
`

type GetLocationRow struct {
	ID               string             `db:"id" json:"id"`
	TripID           string             `db:"trip_id" json:"trip_id"`
	UserID           string             `db:"user_id" json:"user_id"`
	Latitude         float64            `db:"latitude" json:"latitude"`
	Longitude        float64            `db:"longitude" json:"longitude"`
	Accuracy         *float64           `db:"accuracy" json:"accuracy"`
	Timestamp        pgtype.Timestamptz `db:"timestamp" json:"timestamp"`
	LocationName     string             `db:"location_name" json:"location_name"`
	LocationType     string             `db:"location_type" json:"location_type"`
	Notes            string             `db:"notes" json:"notes"`
	Status           string             `db:"status" json:"status"`
	IsSharingEnabled *bool              `db:"is_sharing_enabled" json:"is_sharing_enabled"`
	SharingExpiresAt pgtype.Timestamptz `db:"sharing_expires_at" json:"sharing_expires_at"`
	Privacy          LocationPrivacy    `db:"privacy" json:"privacy"`
	CreatedAt        pgtype.Timestamp   `db:"created_at" json:"created_at"`
	UpdatedAt        pgtype.Timestamp   `db:"updated_at" json:"updated_at"`
}

func (q *Queries) GetLocation(ctx context.Context, id string) (*GetLocationRow, error) {
	row := q.db.QueryRow(ctx, getLocation, id)
	var i GetLocationRow
	err := row.Scan(
		&i.ID,
		&i.TripID,
		&i.UserID,
		&i.Latitude,
		&i.Longitude,
		&i.Accuracy,
		&i.Timestamp,
		&i.LocationName,
		&i.LocationType,
		&i.Notes,
		&i.Status,
		&i.IsSharingEnabled,
		&i.SharingExpiresAt,
		&i.Privacy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const getTripMemberLocations = `-- name: GetTripMemberLocations :many
SELECT DISTINCT ON (l.user_id)
    l.id, l.trip_id, l.user_id, l.latitude, l.longitude, l.accuracy, l.timestamp,
    COALESCE(l.location_name, '') as location_name,
    COALESCE(l.location_type, '') as location_type,
    COALESCE(l.notes, '') as notes,
    COALESCE(l.status, 'planned') as status,
    l.is_sharing_enabled, l.sharing_expires_at, l.privacy,
    l.created_at, l.updated_at,
    COALESCE(up.first_name || ' ' || up.last_name, up.username, '') as user_name,
    tm.role as user_role
FROM locations l
INNER JOIN trip_memberships tm ON l.trip_id = tm.trip_id AND l.user_id = tm.user_id
LEFT JOIN user_profiles up ON l.user_id = up.id
WHERE l.trip_id = $1
    AND tm.status = 'ACTIVE'
    AND l.deleted_at IS NULL
    AND l.is_sharing_enabled = true
ORDER BY l.user_id, l.timestamp DESC
`

type GetTripMemberLocationsRow struct {
	ID               string             `db:"id" json:"id"`
	TripID           string             `db:"trip_id" json:"trip_id"`
	UserID           string             `db:"user_id" json:"user_id"`
	Latitude         float64            `db:"latitude" json:"latitude"`
	Longitude        float64            `db:"longitude" json:"longitude"`
	Accuracy         *float64           `db:"accuracy" json:"accuracy"`
	Timestamp        pgtype.Timestamptz `db:"timestamp" json:"timestamp"`
	LocationName     string             `db:"location_name" json:"location_name"`
	LocationType     string             `db:"location_type" json:"location_type"`
	Notes            string             `db:"notes" json:"notes"`
	Status           string             `db:"status" json:"status"`
	IsSharingEnabled *bool              `db:"is_sharing_enabled" json:"is_sharing_enabled"`
	SharingExpiresAt pgtype.Timestamptz `db:"sharing_expires_at" json:"sharing_expires_at"`
	Privacy          LocationPrivacy    `db:"privacy" json:"privacy"`
	CreatedAt        pgtype.Timestamp   `db:"created_at" json:"created_at"`
	UpdatedAt        pgtype.Timestamp   `db:"updated_at" json:"updated_at"`
	UserName         string             `db:"user_name" json:"user_name"`
	UserRole         MembershipRole     `db:"user_role" json:"user_role"`
}

// Get latest locations for all members of a trip with user info
func (q *Queries) GetTripMemberLocations(ctx context.Context, tripID string) ([]*GetTripMemberLocationsRow, error) {
	rows, err := q.db.Query(ctx, getTripMemberLocations, tripID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetTripMemberLocationsRow{}
	for rows.Next() {
		var i GetTripMemberLocationsRow
		if err := rows.Scan(
			&i.ID,
			&i.TripID,
			&i.UserID,
			&i.Latitude,
			&i.Longitude,
			&i.Accuracy,
			&i.Timestamp,
			&i.LocationName,
			&i.LocationType,
			&i.Notes,
			&i.Status,
			&i.IsSharingEnabled,
			&i.SharingExpiresAt,
			&i.Privacy,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.UserName,
			&i.UserRole,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserLocationInTrip = `-- name: GetUserLocationInTrip :one
SELECT
    id, trip_id, user_id, latitude, longitude, accuracy, timestamp,
    COALESCE(location_name, '') as location_name,
    COALESCE(location_type, '') as location_type,
    COALESCE(notes, '') as notes,
    COALESCE(status, 'planned') as status,
    is_sharing_enabled, sharing_expires_at, privacy,
    created_at, updated_at
FROM locations
WHERE trip_id = $1 AND user_id = $2 AND deleted_at IS NULL
ORDER BY timestamp DESC
LIMIT 1
`

type GetUserLocationInTripParams struct {
	TripID string `db:"trip_id" json:"trip_id"`
	UserID string `db:"user_id" json:"user_id"`
}

type GetUserLocationInTripRow struct {
	ID               string             `db:"id" json:"id"`
	TripID           string             `db:"trip_id" json:"trip_id"`
	UserID           string             `db:"user_id" json:"user_id"`
	Latitude         float64            `db:"latitude" json:"latitude"`
	Longitude        float64            `db:"longitude" json:"longitude"`
	Accuracy         *float64           `db:"accuracy" json:"accuracy"`
	Timestamp        pgtype.Timestamptz `db:"timestamp" json:"timestamp"`
	LocationName     string             `db:"location_name" json:"location_name"`
	LocationType     string             `db:"location_type" json:"location_type"`
	Notes            string             `db:"notes" json:"notes"`
	Status           string             `db:"status" json:"status"`
	IsSharingEnabled *bool              `db:"is_sharing_enabled" json:"is_sharing_enabled"`
	SharingExpiresAt pgtype.Timestamptz `db:"sharing_expires_at" json:"sharing_expires_at"`
	Privacy          LocationPrivacy    `db:"privacy" json:"privacy"`
	CreatedAt        pgtype.Timestamp   `db:"created_at" json:"created_at"`
	UpdatedAt        pgtype.Timestamp   `db:"updated_at" json:"updated_at"`
}

// Get the latest location for a user in a specific trip
func (q *Queries) GetUserLocationInTrip(ctx context.Context, arg GetUserLocationInTripParams) (*GetUserLocationInTripRow, error) {
	row := q.db.QueryRow(ctx, getUserLocationInTrip, arg.TripID, arg.UserID)
	var i GetUserLocationInTripRow
	err := row.Scan(
		&i.ID,
		&i.TripID,
		&i.UserID,
		&i.Latitude,
		&i.Longitude,
		&i.Accuracy,
		&i.Timestamp,
		&i.LocationName,
		&i.LocationType,
		&i.Notes,
		&i.Status,
		&i.IsSharingEnabled,
		&i.SharingExpiresAt,
		&i.Privacy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const softDeleteLocation = `-- name: SoftDeleteLocation :exec
UPDATE locations
SET deleted_at = CURRENT_TIMESTAMP
WHERE id = $1 AND deleted_at IS NULL
`

func (q *Queries) SoftDeleteLocation(ctx context.Context, id string) error {
	_, err := q.db.Exec(ctx, softDeleteLocation, id)
	return err
}

const updateLocation = `-- name: UpdateLocation :exec
UPDATE locations
SET
    latitude = $2,
    longitude = $3,
    accuracy = $4,
    timestamp = $5,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1 AND deleted_at IS NULL
`

type UpdateLocationParams struct {
	ID        string             `db:"id" json:"id"`
	Latitude  float64            `db:"latitude" json:"latitude"`
	Longitude float64            `db:"longitude" json:"longitude"`
	Accuracy  *float64           `db:"accuracy" json:"accuracy"`
	Timestamp pgtype.Timestamptz `db:"timestamp" json:"timestamp"`
}

func (q *Queries) UpdateLocation(ctx context.Context, arg UpdateLocationParams) error {
	_, err := q.db.Exec(ctx, updateLocation,
		arg.ID,
		arg.Latitude,
		arg.Longitude,
		arg.Accuracy,
		arg.Timestamp,
	)
	return err
}

const updateLocationPrivacy = `-- name: UpdateLocationPrivacy :exec
UPDATE locations
SET
    privacy = $2,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1 AND deleted_at IS NULL
`

type UpdateLocationPrivacyParams struct {
	ID      string          `db:"id" json:"id"`
	Privacy LocationPrivacy `db:"privacy" json:"privacy"`
}

func (q *Queries) UpdateLocationPrivacy(ctx context.Context, arg UpdateLocationPrivacyParams) error {
	_, err := q.db.Exec(ctx, updateLocationPrivacy, arg.ID, arg.Privacy)
	return err
}

const updateLocationSharing = `-- name: UpdateLocationSharing :exec
UPDATE locations
SET
    is_sharing_enabled = $2,
    sharing_expires_at = $3,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1 AND deleted_at IS NULL
`

type UpdateLocationSharingParams struct {
	ID               string             `db:"id" json:"id"`
	IsSharingEnabled *bool              `db:"is_sharing_enabled" json:"is_sharing_enabled"`
	SharingExpiresAt pgtype.Timestamptz `db:"sharing_expires_at" json:"sharing_expires_at"`
}

func (q *Queries) UpdateLocationSharing(ctx context.Context, arg UpdateLocationSharingParams) error {
	_, err := q.db.Exec(ctx, updateLocationSharing, arg.ID, arg.IsSharingEnabled, arg.SharingExpiresAt)
	return err
}
