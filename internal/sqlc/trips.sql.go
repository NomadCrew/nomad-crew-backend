// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: trips.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createTrip = `-- name: CreateTrip :one

INSERT INTO trips (
    name, description, start_date, end_date,
    destination_place_id, destination_address, destination_name,
    destination_latitude, destination_longitude,
    created_by, status, background_image_url
)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12)
RETURNING id
`

type CreateTripParams struct {
	Name                 string      `db:"name" json:"name"`
	Description          *string     `db:"description" json:"description"`
	StartDate            pgtype.Date `db:"start_date" json:"start_date"`
	EndDate              pgtype.Date `db:"end_date" json:"end_date"`
	DestinationPlaceID   *string     `db:"destination_place_id" json:"destination_place_id"`
	DestinationAddress   *string     `db:"destination_address" json:"destination_address"`
	DestinationName      *string     `db:"destination_name" json:"destination_name"`
	DestinationLatitude  float64     `db:"destination_latitude" json:"destination_latitude"`
	DestinationLongitude float64     `db:"destination_longitude" json:"destination_longitude"`
	CreatedBy            *string     `db:"created_by" json:"created_by"`
	Status               TripStatus  `db:"status" json:"status"`
	BackgroundImageUrl   *string     `db:"background_image_url" json:"background_image_url"`
}

// Trips CRUD Operations
func (q *Queries) CreateTrip(ctx context.Context, arg CreateTripParams) (string, error) {
	row := q.db.QueryRow(ctx, createTrip,
		arg.Name,
		arg.Description,
		arg.StartDate,
		arg.EndDate,
		arg.DestinationPlaceID,
		arg.DestinationAddress,
		arg.DestinationName,
		arg.DestinationLatitude,
		arg.DestinationLongitude,
		arg.CreatedBy,
		arg.Status,
		arg.BackgroundImageUrl,
	)
	var id string
	err := row.Scan(&id)
	return id, err
}

const getTrip = `-- name: GetTrip :one
SELECT
    id, name, description, start_date, end_date,
    destination_place_id, destination_address, destination_name,
    destination_latitude, destination_longitude,
    status, created_by, created_at, updated_at, deleted_at,
    COALESCE(background_image_url, '') as background_image_url
FROM trips
WHERE id = $1 AND deleted_at IS NULL
`

type GetTripRow struct {
	ID                   string             `db:"id" json:"id"`
	Name                 string             `db:"name" json:"name"`
	Description          *string            `db:"description" json:"description"`
	StartDate            pgtype.Date        `db:"start_date" json:"start_date"`
	EndDate              pgtype.Date        `db:"end_date" json:"end_date"`
	DestinationPlaceID   *string            `db:"destination_place_id" json:"destination_place_id"`
	DestinationAddress   *string            `db:"destination_address" json:"destination_address"`
	DestinationName      *string            `db:"destination_name" json:"destination_name"`
	DestinationLatitude  float64            `db:"destination_latitude" json:"destination_latitude"`
	DestinationLongitude float64            `db:"destination_longitude" json:"destination_longitude"`
	Status               TripStatus         `db:"status" json:"status"`
	CreatedBy            *string            `db:"created_by" json:"created_by"`
	CreatedAt            pgtype.Timestamp   `db:"created_at" json:"created_at"`
	UpdatedAt            pgtype.Timestamp   `db:"updated_at" json:"updated_at"`
	DeletedAt            pgtype.Timestamptz `db:"deleted_at" json:"deleted_at"`
	BackgroundImageUrl   string             `db:"background_image_url" json:"background_image_url"`
}

func (q *Queries) GetTrip(ctx context.Context, id string) (*GetTripRow, error) {
	row := q.db.QueryRow(ctx, getTrip, id)
	var i GetTripRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.StartDate,
		&i.EndDate,
		&i.DestinationPlaceID,
		&i.DestinationAddress,
		&i.DestinationName,
		&i.DestinationLatitude,
		&i.DestinationLongitude,
		&i.Status,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.BackgroundImageUrl,
	)
	return &i, err
}

const getTripForMember = `-- name: GetTripForMember :one
SELECT
    t.id, t.name, t.description, t.start_date, t.end_date,
    t.destination_place_id, t.destination_address, t.destination_name,
    t.destination_latitude, t.destination_longitude,
    t.status, t.created_by, t.created_at, t.updated_at, t.deleted_at,
    COALESCE(t.background_image_url, '') as background_image_url
FROM trips t
INNER JOIN trip_memberships tm ON t.id = tm.trip_id
WHERE t.id = $1
    AND tm.user_id = $2
    AND tm.status = 'ACTIVE'
    AND t.deleted_at IS NULL
`

type GetTripForMemberParams struct {
	ID     string `db:"id" json:"id"`
	UserID string `db:"user_id" json:"user_id"`
}

type GetTripForMemberRow struct {
	ID                   string             `db:"id" json:"id"`
	Name                 string             `db:"name" json:"name"`
	Description          *string            `db:"description" json:"description"`
	StartDate            pgtype.Date        `db:"start_date" json:"start_date"`
	EndDate              pgtype.Date        `db:"end_date" json:"end_date"`
	DestinationPlaceID   *string            `db:"destination_place_id" json:"destination_place_id"`
	DestinationAddress   *string            `db:"destination_address" json:"destination_address"`
	DestinationName      *string            `db:"destination_name" json:"destination_name"`
	DestinationLatitude  float64            `db:"destination_latitude" json:"destination_latitude"`
	DestinationLongitude float64            `db:"destination_longitude" json:"destination_longitude"`
	Status               TripStatus         `db:"status" json:"status"`
	CreatedBy            *string            `db:"created_by" json:"created_by"`
	CreatedAt            pgtype.Timestamp   `db:"created_at" json:"created_at"`
	UpdatedAt            pgtype.Timestamp   `db:"updated_at" json:"updated_at"`
	DeletedAt            pgtype.Timestamptz `db:"deleted_at" json:"deleted_at"`
	BackgroundImageUrl   string             `db:"background_image_url" json:"background_image_url"`
}

// Get a trip that a specific user is a member of
func (q *Queries) GetTripForMember(ctx context.Context, arg GetTripForMemberParams) (*GetTripForMemberRow, error) {
	row := q.db.QueryRow(ctx, getTripForMember, arg.ID, arg.UserID)
	var i GetTripForMemberRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.StartDate,
		&i.EndDate,
		&i.DestinationPlaceID,
		&i.DestinationAddress,
		&i.DestinationName,
		&i.DestinationLatitude,
		&i.DestinationLongitude,
		&i.Status,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.BackgroundImageUrl,
	)
	return &i, err
}

const getTripStatus = `-- name: GetTripStatus :one
SELECT status, deleted_at
FROM trips
WHERE id = $1
`

type GetTripStatusRow struct {
	Status    TripStatus         `db:"status" json:"status"`
	DeletedAt pgtype.Timestamptz `db:"deleted_at" json:"deleted_at"`
}

func (q *Queries) GetTripStatus(ctx context.Context, id string) (*GetTripStatusRow, error) {
	row := q.db.QueryRow(ctx, getTripStatus, id)
	var i GetTripStatusRow
	err := row.Scan(&i.Status, &i.DeletedAt)
	return &i, err
}

const listMemberTrips = `-- name: ListMemberTrips :many
SELECT
    t.id, t.name, t.description, t.start_date, t.end_date,
    t.destination_place_id, t.destination_address, t.destination_name,
    t.destination_latitude, t.destination_longitude,
    t.status, t.created_by, t.created_at, t.updated_at, t.deleted_at,
    COALESCE(t.background_image_url, '') as background_image_url
FROM trips t
INNER JOIN trip_memberships tm ON t.id = tm.trip_id
WHERE tm.user_id = $1
    AND tm.status = 'ACTIVE'
    AND t.deleted_at IS NULL
ORDER BY t.start_date DESC
`

type ListMemberTripsRow struct {
	ID                   string             `db:"id" json:"id"`
	Name                 string             `db:"name" json:"name"`
	Description          *string            `db:"description" json:"description"`
	StartDate            pgtype.Date        `db:"start_date" json:"start_date"`
	EndDate              pgtype.Date        `db:"end_date" json:"end_date"`
	DestinationPlaceID   *string            `db:"destination_place_id" json:"destination_place_id"`
	DestinationAddress   *string            `db:"destination_address" json:"destination_address"`
	DestinationName      *string            `db:"destination_name" json:"destination_name"`
	DestinationLatitude  float64            `db:"destination_latitude" json:"destination_latitude"`
	DestinationLongitude float64            `db:"destination_longitude" json:"destination_longitude"`
	Status               TripStatus         `db:"status" json:"status"`
	CreatedBy            *string            `db:"created_by" json:"created_by"`
	CreatedAt            pgtype.Timestamp   `db:"created_at" json:"created_at"`
	UpdatedAt            pgtype.Timestamp   `db:"updated_at" json:"updated_at"`
	DeletedAt            pgtype.Timestamptz `db:"deleted_at" json:"deleted_at"`
	BackgroundImageUrl   string             `db:"background_image_url" json:"background_image_url"`
}

// Get all trips where user is a member (active membership)
func (q *Queries) ListMemberTrips(ctx context.Context, userID string) ([]*ListMemberTripsRow, error) {
	rows, err := q.db.Query(ctx, listMemberTrips, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ListMemberTripsRow{}
	for rows.Next() {
		var i ListMemberTripsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.StartDate,
			&i.EndDate,
			&i.DestinationPlaceID,
			&i.DestinationAddress,
			&i.DestinationName,
			&i.DestinationLatitude,
			&i.DestinationLongitude,
			&i.Status,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.BackgroundImageUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUserTrips = `-- name: ListUserTrips :many
SELECT
    id, name, description, start_date, end_date,
    destination_place_id, destination_address, destination_name,
    destination_latitude, destination_longitude,
    status, created_by, created_at, updated_at, deleted_at,
    COALESCE(background_image_url, '') as background_image_url
FROM trips
WHERE created_by = $1 AND deleted_at IS NULL
ORDER BY start_date DESC
`

type ListUserTripsRow struct {
	ID                   string             `db:"id" json:"id"`
	Name                 string             `db:"name" json:"name"`
	Description          *string            `db:"description" json:"description"`
	StartDate            pgtype.Date        `db:"start_date" json:"start_date"`
	EndDate              pgtype.Date        `db:"end_date" json:"end_date"`
	DestinationPlaceID   *string            `db:"destination_place_id" json:"destination_place_id"`
	DestinationAddress   *string            `db:"destination_address" json:"destination_address"`
	DestinationName      *string            `db:"destination_name" json:"destination_name"`
	DestinationLatitude  float64            `db:"destination_latitude" json:"destination_latitude"`
	DestinationLongitude float64            `db:"destination_longitude" json:"destination_longitude"`
	Status               TripStatus         `db:"status" json:"status"`
	CreatedBy            *string            `db:"created_by" json:"created_by"`
	CreatedAt            pgtype.Timestamp   `db:"created_at" json:"created_at"`
	UpdatedAt            pgtype.Timestamp   `db:"updated_at" json:"updated_at"`
	DeletedAt            pgtype.Timestamptz `db:"deleted_at" json:"deleted_at"`
	BackgroundImageUrl   string             `db:"background_image_url" json:"background_image_url"`
}

// Get all trips created by a specific user
func (q *Queries) ListUserTrips(ctx context.Context, createdBy *string) ([]*ListUserTripsRow, error) {
	rows, err := q.db.Query(ctx, listUserTrips, createdBy)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ListUserTripsRow{}
	for rows.Next() {
		var i ListUserTripsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.StartDate,
			&i.EndDate,
			&i.DestinationPlaceID,
			&i.DestinationAddress,
			&i.DestinationName,
			&i.DestinationLatitude,
			&i.DestinationLongitude,
			&i.Status,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.BackgroundImageUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchTrips = `-- name: SearchTrips :many
SELECT
    id, name, description, start_date, end_date,
    destination_place_id, destination_address, destination_name,
    destination_latitude, destination_longitude,
    status, created_by, created_at, updated_at, deleted_at,
    COALESCE(background_image_url, '') as background_image_url
FROM trips
WHERE deleted_at IS NULL
    AND (
        COALESCE($1::text, '') = ''
        OR destination_name ILIKE '%' || $1::text || '%'
        OR destination_address ILIKE '%' || $1::text || '%'
    )
    AND ($2::date IS NULL OR start_date >= $2::date)
    AND ($3::date IS NULL OR start_date <= $3::date)
    AND ($4::date IS NULL OR end_date >= $4::date)
    AND ($5::date IS NULL OR end_date <= $5::date)
ORDER BY start_date DESC
`

type SearchTripsParams struct {
	Destination   *string     `db:"destination" json:"destination"`
	StartDateFrom pgtype.Date `db:"start_date_from" json:"start_date_from"`
	StartDateTo   pgtype.Date `db:"start_date_to" json:"start_date_to"`
	EndDateFrom   pgtype.Date `db:"end_date_from" json:"end_date_from"`
	EndDateTo     pgtype.Date `db:"end_date_to" json:"end_date_to"`
}

type SearchTripsRow struct {
	ID                   string             `db:"id" json:"id"`
	Name                 string             `db:"name" json:"name"`
	Description          *string            `db:"description" json:"description"`
	StartDate            pgtype.Date        `db:"start_date" json:"start_date"`
	EndDate              pgtype.Date        `db:"end_date" json:"end_date"`
	DestinationPlaceID   *string            `db:"destination_place_id" json:"destination_place_id"`
	DestinationAddress   *string            `db:"destination_address" json:"destination_address"`
	DestinationName      *string            `db:"destination_name" json:"destination_name"`
	DestinationLatitude  float64            `db:"destination_latitude" json:"destination_latitude"`
	DestinationLongitude float64            `db:"destination_longitude" json:"destination_longitude"`
	Status               TripStatus         `db:"status" json:"status"`
	CreatedBy            *string            `db:"created_by" json:"created_by"`
	CreatedAt            pgtype.Timestamp   `db:"created_at" json:"created_at"`
	UpdatedAt            pgtype.Timestamp   `db:"updated_at" json:"updated_at"`
	DeletedAt            pgtype.Timestamptz `db:"deleted_at" json:"deleted_at"`
	BackgroundImageUrl   string             `db:"background_image_url" json:"background_image_url"`
}

// Search trips by destination name/address with optional date filters
func (q *Queries) SearchTrips(ctx context.Context, arg SearchTripsParams) ([]*SearchTripsRow, error) {
	rows, err := q.db.Query(ctx, searchTrips,
		arg.Destination,
		arg.StartDateFrom,
		arg.StartDateTo,
		arg.EndDateFrom,
		arg.EndDateTo,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*SearchTripsRow{}
	for rows.Next() {
		var i SearchTripsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.StartDate,
			&i.EndDate,
			&i.DestinationPlaceID,
			&i.DestinationAddress,
			&i.DestinationName,
			&i.DestinationLatitude,
			&i.DestinationLongitude,
			&i.Status,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.BackgroundImageUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const softDeleteTrip = `-- name: SoftDeleteTrip :exec
UPDATE trips
SET deleted_at = CURRENT_TIMESTAMP
WHERE id = $1 AND deleted_at IS NULL
`

func (q *Queries) SoftDeleteTrip(ctx context.Context, id string) error {
	_, err := q.db.Exec(ctx, softDeleteTrip, id)
	return err
}

const updateTripDates = `-- name: UpdateTripDates :exec
UPDATE trips
SET start_date = $2, end_date = $3, updated_at = CURRENT_TIMESTAMP
WHERE id = $1 AND deleted_at IS NULL
`

type UpdateTripDatesParams struct {
	ID        string      `db:"id" json:"id"`
	StartDate pgtype.Date `db:"start_date" json:"start_date"`
	EndDate   pgtype.Date `db:"end_date" json:"end_date"`
}

func (q *Queries) UpdateTripDates(ctx context.Context, arg UpdateTripDatesParams) error {
	_, err := q.db.Exec(ctx, updateTripDates, arg.ID, arg.StartDate, arg.EndDate)
	return err
}

const updateTripDescription = `-- name: UpdateTripDescription :exec
UPDATE trips
SET description = $2, updated_at = CURRENT_TIMESTAMP
WHERE id = $1 AND deleted_at IS NULL
`

type UpdateTripDescriptionParams struct {
	ID          string  `db:"id" json:"id"`
	Description *string `db:"description" json:"description"`
}

func (q *Queries) UpdateTripDescription(ctx context.Context, arg UpdateTripDescriptionParams) error {
	_, err := q.db.Exec(ctx, updateTripDescription, arg.ID, arg.Description)
	return err
}

const updateTripDestination = `-- name: UpdateTripDestination :exec
UPDATE trips
SET
    destination_place_id = $2,
    destination_address = $3,
    destination_name = $4,
    destination_latitude = $5,
    destination_longitude = $6,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1 AND deleted_at IS NULL
`

type UpdateTripDestinationParams struct {
	ID                   string  `db:"id" json:"id"`
	DestinationPlaceID   *string `db:"destination_place_id" json:"destination_place_id"`
	DestinationAddress   *string `db:"destination_address" json:"destination_address"`
	DestinationName      *string `db:"destination_name" json:"destination_name"`
	DestinationLatitude  float64 `db:"destination_latitude" json:"destination_latitude"`
	DestinationLongitude float64 `db:"destination_longitude" json:"destination_longitude"`
}

func (q *Queries) UpdateTripDestination(ctx context.Context, arg UpdateTripDestinationParams) error {
	_, err := q.db.Exec(ctx, updateTripDestination,
		arg.ID,
		arg.DestinationPlaceID,
		arg.DestinationAddress,
		arg.DestinationName,
		arg.DestinationLatitude,
		arg.DestinationLongitude,
	)
	return err
}

const updateTripName = `-- name: UpdateTripName :exec
UPDATE trips
SET name = $2, updated_at = CURRENT_TIMESTAMP
WHERE id = $1 AND deleted_at IS NULL
`

type UpdateTripNameParams struct {
	ID   string `db:"id" json:"id"`
	Name string `db:"name" json:"name"`
}

func (q *Queries) UpdateTripName(ctx context.Context, arg UpdateTripNameParams) error {
	_, err := q.db.Exec(ctx, updateTripName, arg.ID, arg.Name)
	return err
}

const updateTripStatus = `-- name: UpdateTripStatus :exec
UPDATE trips
SET status = $2, updated_at = CURRENT_TIMESTAMP
WHERE id = $1 AND deleted_at IS NULL
`

type UpdateTripStatusParams struct {
	ID     string     `db:"id" json:"id"`
	Status TripStatus `db:"status" json:"status"`
}

func (q *Queries) UpdateTripStatus(ctx context.Context, arg UpdateTripStatusParams) error {
	_, err := q.db.Exec(ctx, updateTripStatus, arg.ID, arg.Status)
	return err
}
