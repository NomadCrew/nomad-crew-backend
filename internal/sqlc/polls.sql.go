// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: polls.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const castVote = `-- name: CastVote :exec
INSERT INTO poll_votes (poll_id, option_id, user_id)
VALUES ($1, $2, $3)
ON CONFLICT (poll_id, option_id, user_id) DO NOTHING
`

type CastVoteParams struct {
	PollID   string `db:"poll_id" json:"poll_id"`
	OptionID string `db:"option_id" json:"option_id"`
	UserID   string `db:"user_id" json:"user_id"`
}

func (q *Queries) CastVote(ctx context.Context, arg CastVoteParams) error {
	_, err := q.db.Exec(ctx, castVote, arg.PollID, arg.OptionID, arg.UserID)
	return err
}

const closePoll = `-- name: ClosePoll :one
UPDATE polls
SET status = 'CLOSED', closed_by = $3, closed_at = CURRENT_TIMESTAMP, updated_at = CURRENT_TIMESTAMP
WHERE id = $1 AND trip_id = $2 AND deleted_at IS NULL AND status = 'ACTIVE'
RETURNING id, trip_id, question, allow_multiple_votes, status, created_by, closed_by, closed_at, created_at, updated_at, deleted_at, expires_at
`

type ClosePollParams struct {
	ID       string  `db:"id" json:"id"`
	TripID   string  `db:"trip_id" json:"trip_id"`
	ClosedBy *string `db:"closed_by" json:"closed_by"`
}

func (q *Queries) ClosePoll(ctx context.Context, arg ClosePollParams) (*Poll, error) {
	row := q.db.QueryRow(ctx, closePoll, arg.ID, arg.TripID, arg.ClosedBy)
	var i Poll
	err := row.Scan(
		&i.ID,
		&i.TripID,
		&i.Question,
		&i.AllowMultipleVotes,
		&i.Status,
		&i.CreatedBy,
		&i.ClosedBy,
		&i.ClosedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.ExpiresAt,
	)
	return &i, err
}

const countPollsByTrip = `-- name: CountPollsByTrip :one
SELECT COUNT(*) as count FROM polls
WHERE trip_id = $1 AND deleted_at IS NULL
`

func (q *Queries) CountPollsByTrip(ctx context.Context, tripID string) (int64, error) {
	row := q.db.QueryRow(ctx, countPollsByTrip, tripID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countUniqueVotersByPoll = `-- name: CountUniqueVotersByPoll :one
SELECT COUNT(DISTINCT user_id) as count
FROM poll_votes
WHERE poll_id = $1
`

func (q *Queries) CountUniqueVotersByPoll(ctx context.Context, pollID string) (int64, error) {
	row := q.db.QueryRow(ctx, countUniqueVotersByPoll, pollID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createPoll = `-- name: CreatePoll :one

INSERT INTO polls (trip_id, question, allow_multiple_votes, created_by, expires_at)
VALUES ($1, $2, $3, $4, $5)
RETURNING id, trip_id, question, allow_multiple_votes, status, created_by, closed_by, closed_at, created_at, updated_at, deleted_at, expires_at
`

type CreatePollParams struct {
	TripID             string             `db:"trip_id" json:"trip_id"`
	Question           string             `db:"question" json:"question"`
	AllowMultipleVotes bool               `db:"allow_multiple_votes" json:"allow_multiple_votes"`
	CreatedBy          string             `db:"created_by" json:"created_by"`
	ExpiresAt          pgtype.Timestamptz `db:"expires_at" json:"expires_at"`
}

// Poll Operations
func (q *Queries) CreatePoll(ctx context.Context, arg CreatePollParams) (*Poll, error) {
	row := q.db.QueryRow(ctx, createPoll,
		arg.TripID,
		arg.Question,
		arg.AllowMultipleVotes,
		arg.CreatedBy,
		arg.ExpiresAt,
	)
	var i Poll
	err := row.Scan(
		&i.ID,
		&i.TripID,
		&i.Question,
		&i.AllowMultipleVotes,
		&i.Status,
		&i.CreatedBy,
		&i.ClosedBy,
		&i.ClosedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.ExpiresAt,
	)
	return &i, err
}

const createPollOption = `-- name: CreatePollOption :one
INSERT INTO poll_options (poll_id, text, position, created_by)
VALUES ($1, $2, $3, $4)
RETURNING id, poll_id, text, position, created_by, created_at
`

type CreatePollOptionParams struct {
	PollID    string `db:"poll_id" json:"poll_id"`
	Text      string `db:"text" json:"text"`
	Position  int16  `db:"position" json:"position"`
	CreatedBy string `db:"created_by" json:"created_by"`
}

func (q *Queries) CreatePollOption(ctx context.Context, arg CreatePollOptionParams) (*PollOption, error) {
	row := q.db.QueryRow(ctx, createPollOption,
		arg.PollID,
		arg.Text,
		arg.Position,
		arg.CreatedBy,
	)
	var i PollOption
	err := row.Scan(
		&i.ID,
		&i.PollID,
		&i.Text,
		&i.Position,
		&i.CreatedBy,
		&i.CreatedAt,
	)
	return &i, err
}

const getPoll = `-- name: GetPoll :one
SELECT id, trip_id, question, allow_multiple_votes, status, created_by, closed_by, closed_at, created_at, updated_at, deleted_at, expires_at FROM polls
WHERE id = $1 AND trip_id = $2 AND deleted_at IS NULL
`

type GetPollParams struct {
	ID     string `db:"id" json:"id"`
	TripID string `db:"trip_id" json:"trip_id"`
}

func (q *Queries) GetPoll(ctx context.Context, arg GetPollParams) (*Poll, error) {
	row := q.db.QueryRow(ctx, getPoll, arg.ID, arg.TripID)
	var i Poll
	err := row.Scan(
		&i.ID,
		&i.TripID,
		&i.Question,
		&i.AllowMultipleVotes,
		&i.Status,
		&i.CreatedBy,
		&i.ClosedBy,
		&i.ClosedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.ExpiresAt,
	)
	return &i, err
}

const getUserVotesForPoll = `-- name: GetUserVotesForPoll :many
SELECT id, poll_id, option_id, user_id, created_at FROM poll_votes
WHERE poll_id = $1 AND user_id = $2
`

type GetUserVotesForPollParams struct {
	PollID string `db:"poll_id" json:"poll_id"`
	UserID string `db:"user_id" json:"user_id"`
}

func (q *Queries) GetUserVotesForPoll(ctx context.Context, arg GetUserVotesForPollParams) ([]*PollVote, error) {
	rows, err := q.db.Query(ctx, getUserVotesForPoll, arg.PollID, arg.UserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*PollVote{}
	for rows.Next() {
		var i PollVote
		if err := rows.Scan(
			&i.ID,
			&i.PollID,
			&i.OptionID,
			&i.UserID,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getVoteCountsByPoll = `-- name: GetVoteCountsByPoll :many
SELECT option_id, COUNT(*) as vote_count
FROM poll_votes
WHERE poll_id = $1
GROUP BY option_id
`

type GetVoteCountsByPollRow struct {
	OptionID  string `db:"option_id" json:"option_id"`
	VoteCount int64  `db:"vote_count" json:"vote_count"`
}

func (q *Queries) GetVoteCountsByPoll(ctx context.Context, pollID string) ([]*GetVoteCountsByPollRow, error) {
	rows, err := q.db.Query(ctx, getVoteCountsByPoll, pollID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetVoteCountsByPollRow{}
	for rows.Next() {
		var i GetVoteCountsByPollRow
		if err := rows.Scan(&i.OptionID, &i.VoteCount); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPollOptions = `-- name: ListPollOptions :many
SELECT id, poll_id, text, position, created_by, created_at FROM poll_options
WHERE poll_id = $1
ORDER BY position ASC
`

func (q *Queries) ListPollOptions(ctx context.Context, pollID string) ([]*PollOption, error) {
	rows, err := q.db.Query(ctx, listPollOptions, pollID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*PollOption{}
	for rows.Next() {
		var i PollOption
		if err := rows.Scan(
			&i.ID,
			&i.PollID,
			&i.Text,
			&i.Position,
			&i.CreatedBy,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPollsByTrip = `-- name: ListPollsByTrip :many
SELECT id, trip_id, question, allow_multiple_votes, status, created_by, closed_by, closed_at, created_at, updated_at, deleted_at, expires_at FROM polls
WHERE trip_id = $1 AND deleted_at IS NULL
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListPollsByTripParams struct {
	TripID string `db:"trip_id" json:"trip_id"`
	Limit  int32  `db:"limit" json:"limit"`
	Offset int32  `db:"offset" json:"offset"`
}

func (q *Queries) ListPollsByTrip(ctx context.Context, arg ListPollsByTripParams) ([]*Poll, error) {
	rows, err := q.db.Query(ctx, listPollsByTrip, arg.TripID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Poll{}
	for rows.Next() {
		var i Poll
		if err := rows.Scan(
			&i.ID,
			&i.TripID,
			&i.Question,
			&i.AllowMultipleVotes,
			&i.Status,
			&i.CreatedBy,
			&i.ClosedBy,
			&i.ClosedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.ExpiresAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listVotesByPoll = `-- name: ListVotesByPoll :many
SELECT id, poll_id, option_id, user_id, created_at FROM poll_votes
WHERE poll_id = $1
`

func (q *Queries) ListVotesByPoll(ctx context.Context, pollID string) ([]*PollVote, error) {
	rows, err := q.db.Query(ctx, listVotesByPoll, pollID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*PollVote{}
	for rows.Next() {
		var i PollVote
		if err := rows.Scan(
			&i.ID,
			&i.PollID,
			&i.OptionID,
			&i.UserID,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeAllUserVotesForPoll = `-- name: RemoveAllUserVotesForPoll :exec
DELETE FROM poll_votes
WHERE poll_id = $1 AND user_id = $2
`

type RemoveAllUserVotesForPollParams struct {
	PollID string `db:"poll_id" json:"poll_id"`
	UserID string `db:"user_id" json:"user_id"`
}

func (q *Queries) RemoveAllUserVotesForPoll(ctx context.Context, arg RemoveAllUserVotesForPollParams) error {
	_, err := q.db.Exec(ctx, removeAllUserVotesForPoll, arg.PollID, arg.UserID)
	return err
}

const removeVote = `-- name: RemoveVote :exec
DELETE FROM poll_votes
WHERE poll_id = $1 AND option_id = $2 AND user_id = $3
`

type RemoveVoteParams struct {
	PollID   string `db:"poll_id" json:"poll_id"`
	OptionID string `db:"option_id" json:"option_id"`
	UserID   string `db:"user_id" json:"user_id"`
}

func (q *Queries) RemoveVote(ctx context.Context, arg RemoveVoteParams) error {
	_, err := q.db.Exec(ctx, removeVote, arg.PollID, arg.OptionID, arg.UserID)
	return err
}

const softDeletePoll = `-- name: SoftDeletePoll :exec
UPDATE polls
SET deleted_at = CURRENT_TIMESTAMP, updated_at = CURRENT_TIMESTAMP
WHERE id = $1 AND trip_id = $2 AND deleted_at IS NULL
`

type SoftDeletePollParams struct {
	ID     string `db:"id" json:"id"`
	TripID string `db:"trip_id" json:"trip_id"`
}

func (q *Queries) SoftDeletePoll(ctx context.Context, arg SoftDeletePollParams) error {
	_, err := q.db.Exec(ctx, softDeletePoll, arg.ID, arg.TripID)
	return err
}

const updatePollQuestion = `-- name: UpdatePollQuestion :one
UPDATE polls
SET question = $3, updated_at = CURRENT_TIMESTAMP
WHERE id = $1 AND trip_id = $2 AND deleted_at IS NULL
RETURNING id, trip_id, question, allow_multiple_votes, status, created_by, closed_by, closed_at, created_at, updated_at, deleted_at, expires_at
`

type UpdatePollQuestionParams struct {
	ID       string `db:"id" json:"id"`
	TripID   string `db:"trip_id" json:"trip_id"`
	Question string `db:"question" json:"question"`
}

func (q *Queries) UpdatePollQuestion(ctx context.Context, arg UpdatePollQuestionParams) (*Poll, error) {
	row := q.db.QueryRow(ctx, updatePollQuestion, arg.ID, arg.TripID, arg.Question)
	var i Poll
	err := row.Scan(
		&i.ID,
		&i.TripID,
		&i.Question,
		&i.AllowMultipleVotes,
		&i.Status,
		&i.CreatedBy,
		&i.ClosedBy,
		&i.ClosedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.ExpiresAt,
	)
	return &i, err
}
