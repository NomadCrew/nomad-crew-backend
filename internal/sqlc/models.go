// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0

package sqlc

import (
	"database/sql/driver"
	"fmt"

	"github.com/jackc/pgx/v5/pgtype"
)

type InvitationStatus string

const (
	InvitationStatusPENDING  InvitationStatus = "PENDING"
	InvitationStatusACCEPTED InvitationStatus = "ACCEPTED"
	InvitationStatusDECLINED InvitationStatus = "DECLINED"
)

func (e *InvitationStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = InvitationStatus(s)
	case string:
		*e = InvitationStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for InvitationStatus: %T", src)
	}
	return nil
}

type NullInvitationStatus struct {
	InvitationStatus InvitationStatus `json:"invitation_status"`
	Valid            bool             `json:"valid"` // Valid is true if InvitationStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullInvitationStatus) Scan(value interface{}) error {
	if value == nil {
		ns.InvitationStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.InvitationStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullInvitationStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.InvitationStatus), nil
}

func (e InvitationStatus) Valid() bool {
	switch e {
	case InvitationStatusPENDING,
		InvitationStatusACCEPTED,
		InvitationStatusDECLINED:
		return true
	}
	return false
}

func AllInvitationStatusValues() []InvitationStatus {
	return []InvitationStatus{
		InvitationStatusPENDING,
		InvitationStatusACCEPTED,
		InvitationStatusDECLINED,
	}
}

type LocationPrivacy string

const (
	LocationPrivacyHidden      LocationPrivacy = "hidden"
	LocationPrivacyApproximate LocationPrivacy = "approximate"
	LocationPrivacyPrecise     LocationPrivacy = "precise"
)

func (e *LocationPrivacy) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = LocationPrivacy(s)
	case string:
		*e = LocationPrivacy(s)
	default:
		return fmt.Errorf("unsupported scan type for LocationPrivacy: %T", src)
	}
	return nil
}

type NullLocationPrivacy struct {
	LocationPrivacy LocationPrivacy `json:"location_privacy"`
	Valid           bool            `json:"valid"` // Valid is true if LocationPrivacy is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullLocationPrivacy) Scan(value interface{}) error {
	if value == nil {
		ns.LocationPrivacy, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.LocationPrivacy.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullLocationPrivacy) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.LocationPrivacy), nil
}

func (e LocationPrivacy) Valid() bool {
	switch e {
	case LocationPrivacyHidden,
		LocationPrivacyApproximate,
		LocationPrivacyPrecise:
		return true
	}
	return false
}

func AllLocationPrivacyValues() []LocationPrivacy {
	return []LocationPrivacy{
		LocationPrivacyHidden,
		LocationPrivacyApproximate,
		LocationPrivacyPrecise,
	}
}

type MembershipRole string

const (
	MembershipRoleOWNER  MembershipRole = "OWNER"
	MembershipRoleMEMBER MembershipRole = "MEMBER"
	MembershipRoleADMIN  MembershipRole = "ADMIN"
)

func (e *MembershipRole) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = MembershipRole(s)
	case string:
		*e = MembershipRole(s)
	default:
		return fmt.Errorf("unsupported scan type for MembershipRole: %T", src)
	}
	return nil
}

type NullMembershipRole struct {
	MembershipRole MembershipRole `json:"membership_role"`
	Valid          bool           `json:"valid"` // Valid is true if MembershipRole is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullMembershipRole) Scan(value interface{}) error {
	if value == nil {
		ns.MembershipRole, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.MembershipRole.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullMembershipRole) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.MembershipRole), nil
}

func (e MembershipRole) Valid() bool {
	switch e {
	case MembershipRoleOWNER,
		MembershipRoleMEMBER,
		MembershipRoleADMIN:
		return true
	}
	return false
}

func AllMembershipRoleValues() []MembershipRole {
	return []MembershipRole{
		MembershipRoleOWNER,
		MembershipRoleMEMBER,
		MembershipRoleADMIN,
	}
}

type MembershipStatus string

const (
	MembershipStatusACTIVE   MembershipStatus = "ACTIVE"
	MembershipStatusINACTIVE MembershipStatus = "INACTIVE"
)

func (e *MembershipStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = MembershipStatus(s)
	case string:
		*e = MembershipStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for MembershipStatus: %T", src)
	}
	return nil
}

type NullMembershipStatus struct {
	MembershipStatus MembershipStatus `json:"membership_status"`
	Valid            bool             `json:"valid"` // Valid is true if MembershipStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullMembershipStatus) Scan(value interface{}) error {
	if value == nil {
		ns.MembershipStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.MembershipStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullMembershipStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.MembershipStatus), nil
}

func (e MembershipStatus) Valid() bool {
	switch e {
	case MembershipStatusACTIVE,
		MembershipStatusINACTIVE:
		return true
	}
	return false
}

func AllMembershipStatusValues() []MembershipStatus {
	return []MembershipStatus{
		MembershipStatusACTIVE,
		MembershipStatusINACTIVE,
	}
}

type NotificationType string

const (
	NotificationTypeTRIPINVITATIONRECEIVED NotificationType = "TRIP_INVITATION_RECEIVED"
	NotificationTypeTRIPINVITATIONACCEPTED NotificationType = "TRIP_INVITATION_ACCEPTED"
	NotificationTypeTRIPINVITATIONDECLINED NotificationType = "TRIP_INVITATION_DECLINED"
	NotificationTypeTRIPUPDATE             NotificationType = "TRIP_UPDATE"
	NotificationTypeNEWCHATMESSAGE         NotificationType = "NEW_CHAT_MESSAGE"
	NotificationTypeEXPENSEREPORTSUBMITTED NotificationType = "EXPENSE_REPORT_SUBMITTED"
	NotificationTypeTASKASSIGNED           NotificationType = "TASK_ASSIGNED"
	NotificationTypeTASKCOMPLETED          NotificationType = "TASK_COMPLETED"
	NotificationTypeLOCATIONSHARED         NotificationType = "LOCATION_SHARED"
	NotificationTypeMEMBERSHIPCHANGE       NotificationType = "MEMBERSHIP_CHANGE"
)

func (e *NotificationType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = NotificationType(s)
	case string:
		*e = NotificationType(s)
	default:
		return fmt.Errorf("unsupported scan type for NotificationType: %T", src)
	}
	return nil
}

type NullNotificationType struct {
	NotificationType NotificationType `json:"notification_type"`
	Valid            bool             `json:"valid"` // Valid is true if NotificationType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullNotificationType) Scan(value interface{}) error {
	if value == nil {
		ns.NotificationType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.NotificationType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullNotificationType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.NotificationType), nil
}

func (e NotificationType) Valid() bool {
	switch e {
	case NotificationTypeTRIPINVITATIONRECEIVED,
		NotificationTypeTRIPINVITATIONACCEPTED,
		NotificationTypeTRIPINVITATIONDECLINED,
		NotificationTypeTRIPUPDATE,
		NotificationTypeNEWCHATMESSAGE,
		NotificationTypeEXPENSEREPORTSUBMITTED,
		NotificationTypeTASKASSIGNED,
		NotificationTypeTASKCOMPLETED,
		NotificationTypeLOCATIONSHARED,
		NotificationTypeMEMBERSHIPCHANGE:
		return true
	}
	return false
}

func AllNotificationTypeValues() []NotificationType {
	return []NotificationType{
		NotificationTypeTRIPINVITATIONRECEIVED,
		NotificationTypeTRIPINVITATIONACCEPTED,
		NotificationTypeTRIPINVITATIONDECLINED,
		NotificationTypeTRIPUPDATE,
		NotificationTypeNEWCHATMESSAGE,
		NotificationTypeEXPENSEREPORTSUBMITTED,
		NotificationTypeTASKASSIGNED,
		NotificationTypeTASKCOMPLETED,
		NotificationTypeLOCATIONSHARED,
		NotificationTypeMEMBERSHIPCHANGE,
	}
}

type TodoStatus string

const (
	TodoStatusCOMPLETE   TodoStatus = "COMPLETE"
	TodoStatusINCOMPLETE TodoStatus = "INCOMPLETE"
)

func (e *TodoStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = TodoStatus(s)
	case string:
		*e = TodoStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for TodoStatus: %T", src)
	}
	return nil
}

type NullTodoStatus struct {
	TodoStatus TodoStatus `json:"todo_status"`
	Valid      bool       `json:"valid"` // Valid is true if TodoStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullTodoStatus) Scan(value interface{}) error {
	if value == nil {
		ns.TodoStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.TodoStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullTodoStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.TodoStatus), nil
}

func (e TodoStatus) Valid() bool {
	switch e {
	case TodoStatusCOMPLETE,
		TodoStatusINCOMPLETE:
		return true
	}
	return false
}

func AllTodoStatusValues() []TodoStatus {
	return []TodoStatus{
		TodoStatusCOMPLETE,
		TodoStatusINCOMPLETE,
	}
}

type TripStatus string

const (
	TripStatusPLANNING  TripStatus = "PLANNING"
	TripStatusACTIVE    TripStatus = "ACTIVE"
	TripStatusCOMPLETED TripStatus = "COMPLETED"
	TripStatusCANCELLED TripStatus = "CANCELLED"
)

func (e *TripStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = TripStatus(s)
	case string:
		*e = TripStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for TripStatus: %T", src)
	}
	return nil
}

type NullTripStatus struct {
	TripStatus TripStatus `json:"trip_status"`
	Valid      bool       `json:"valid"` // Valid is true if TripStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullTripStatus) Scan(value interface{}) error {
	if value == nil {
		ns.TripStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.TripStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullTripStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.TripStatus), nil
}

func (e TripStatus) Valid() bool {
	switch e {
	case TripStatusPLANNING,
		TripStatusACTIVE,
		TripStatusCOMPLETED,
		TripStatusCANCELLED:
		return true
	}
	return false
}

func AllTripStatusValues() []TripStatus {
	return []TripStatus{
		TripStatusPLANNING,
		TripStatusACTIVE,
		TripStatusCOMPLETED,
		TripStatusCANCELLED,
	}
}

type AuthUser struct {
	ID        string             `db:"id" json:"id"`
	Email     *string            `db:"email" json:"email"`
	CreatedAt pgtype.Timestamptz `db:"created_at" json:"created_at"`
	UpdatedAt pgtype.Timestamptz `db:"updated_at" json:"updated_at"`
}

type Category struct {
	ID        string           `db:"id" json:"id"`
	Name      string           `db:"name" json:"name"`
	Type      string           `db:"type" json:"type"`
	CreatedAt pgtype.Timestamp `db:"created_at" json:"created_at"`
	UpdatedAt pgtype.Timestamp `db:"updated_at" json:"updated_at"`
}

type ChatGroup struct {
	ID          string             `db:"id" json:"id"`
	TripID      string             `db:"trip_id" json:"trip_id"`
	Name        string             `db:"name" json:"name"`
	Description *string            `db:"description" json:"description"`
	CreatedBy   *string            `db:"created_by" json:"created_by"`
	CreatedAt   pgtype.Timestamptz `db:"created_at" json:"created_at"`
	UpdatedAt   pgtype.Timestamptz `db:"updated_at" json:"updated_at"`
	DeletedAt   pgtype.Timestamptz `db:"deleted_at" json:"deleted_at"`
}

type ChatGroupMember struct {
	GroupID           string             `db:"group_id" json:"group_id"`
	UserID            string             `db:"user_id" json:"user_id"`
	JoinedAt          pgtype.Timestamptz `db:"joined_at" json:"joined_at"`
	LastReadMessageID *string            `db:"last_read_message_id" json:"last_read_message_id"`
}

type ChatMessage struct {
	ID          string             `db:"id" json:"id"`
	GroupID     string             `db:"group_id" json:"group_id"`
	UserID      *string            `db:"user_id" json:"user_id"`
	Content     string             `db:"content" json:"content"`
	ContentType string             `db:"content_type" json:"content_type"`
	CreatedAt   pgtype.Timestamptz `db:"created_at" json:"created_at"`
	UpdatedAt   pgtype.Timestamptz `db:"updated_at" json:"updated_at"`
	DeletedAt   pgtype.Timestamptz `db:"deleted_at" json:"deleted_at"`
}

type ChatMessageReaction struct {
	MessageID string             `db:"message_id" json:"message_id"`
	UserID    string             `db:"user_id" json:"user_id"`
	Reaction  string             `db:"reaction" json:"reaction"`
	CreatedAt pgtype.Timestamptz `db:"created_at" json:"created_at"`
}

type Expense struct {
	ID            string             `db:"id" json:"id"`
	TripID        string             `db:"trip_id" json:"trip_id"`
	UserID        string             `db:"user_id" json:"user_id"`
	Amount        pgtype.Numeric     `db:"amount" json:"amount"`
	Description   *string            `db:"description" json:"description"`
	Category      *string            `db:"category" json:"category"`
	PaymentMethod *string            `db:"payment_method" json:"payment_method"`
	Receipt       *string            `db:"receipt" json:"receipt"`
	Status        *string            `db:"status" json:"status"`
	CreatedAt     pgtype.Timestamp   `db:"created_at" json:"created_at"`
	UpdatedAt     pgtype.Timestamp   `db:"updated_at" json:"updated_at"`
	DeletedAt     pgtype.Timestamptz `db:"deleted_at" json:"deleted_at"`
}

type Location struct {
	ID               string             `db:"id" json:"id"`
	TripID           string             `db:"trip_id" json:"trip_id"`
	UserID           string             `db:"user_id" json:"user_id"`
	Latitude         float64            `db:"latitude" json:"latitude"`
	Longitude        float64            `db:"longitude" json:"longitude"`
	Accuracy         *float64           `db:"accuracy" json:"accuracy"`
	Timestamp        pgtype.Timestamptz `db:"timestamp" json:"timestamp"`
	LocationName     *string            `db:"location_name" json:"location_name"`
	LocationType     *string            `db:"location_type" json:"location_type"`
	Notes            *string            `db:"notes" json:"notes"`
	Status           *string            `db:"status" json:"status"`
	IsSharingEnabled *bool              `db:"is_sharing_enabled" json:"is_sharing_enabled"`
	SharingExpiresAt pgtype.Timestamptz `db:"sharing_expires_at" json:"sharing_expires_at"`
	Privacy          LocationPrivacy    `db:"privacy" json:"privacy"`
	CreatedAt        pgtype.Timestamp   `db:"created_at" json:"created_at"`
	UpdatedAt        pgtype.Timestamp   `db:"updated_at" json:"updated_at"`
	DeletedAt        pgtype.Timestamptz `db:"deleted_at" json:"deleted_at"`
}

type Notification struct {
	ID        string             `db:"id" json:"id"`
	UserID    string             `db:"user_id" json:"user_id"`
	Type      NotificationType   `db:"type" json:"type"`
	Metadata  []byte             `db:"metadata" json:"metadata"`
	IsRead    bool               `db:"is_read" json:"is_read"`
	CreatedAt pgtype.Timestamptz `db:"created_at" json:"created_at"`
	UpdatedAt pgtype.Timestamptz `db:"updated_at" json:"updated_at"`
}

type Todo struct {
	ID        string             `db:"id" json:"id"`
	TripID    string             `db:"trip_id" json:"trip_id"`
	Text      string             `db:"text" json:"text"`
	Status    TodoStatus         `db:"status" json:"status"`
	CreatedBy string             `db:"created_by" json:"created_by"`
	CreatedAt pgtype.Timestamptz `db:"created_at" json:"created_at"`
	UpdatedAt pgtype.Timestamptz `db:"updated_at" json:"updated_at"`
	DeletedAt pgtype.Timestamptz `db:"deleted_at" json:"deleted_at"`
}

type Trip struct {
	ID                   string             `db:"id" json:"id"`
	Name                 string             `db:"name" json:"name"`
	Description          *string            `db:"description" json:"description"`
	StartDate            pgtype.Date        `db:"start_date" json:"start_date"`
	EndDate              pgtype.Date        `db:"end_date" json:"end_date"`
	DestinationPlaceID   *string            `db:"destination_place_id" json:"destination_place_id"`
	DestinationAddress   *string            `db:"destination_address" json:"destination_address"`
	DestinationName      *string            `db:"destination_name" json:"destination_name"`
	DestinationLatitude  float64            `db:"destination_latitude" json:"destination_latitude"`
	DestinationLongitude float64            `db:"destination_longitude" json:"destination_longitude"`
	Status               TripStatus         `db:"status" json:"status"`
	CreatedBy            *string            `db:"created_by" json:"created_by"`
	CreatedAt            pgtype.Timestamp   `db:"created_at" json:"created_at"`
	UpdatedAt            pgtype.Timestamp   `db:"updated_at" json:"updated_at"`
	BackgroundImageUrl   *string            `db:"background_image_url" json:"background_image_url"`
	DeletedAt            pgtype.Timestamptz `db:"deleted_at" json:"deleted_at"`
}

type TripInvitation struct {
	ID           string             `db:"id" json:"id"`
	TripID       string             `db:"trip_id" json:"trip_id"`
	InviterID    *string            `db:"inviter_id" json:"inviter_id"`
	InviteeID    *string            `db:"invitee_id" json:"invitee_id"`
	InviteeEmail string             `db:"invitee_email" json:"invitee_email"`
	Role         MembershipRole     `db:"role" json:"role"`
	Token        *string            `db:"token" json:"token"`
	Status       InvitationStatus   `db:"status" json:"status"`
	ExpiresAt    pgtype.Timestamptz `db:"expires_at" json:"expires_at"`
	CreatedAt    pgtype.Timestamptz `db:"created_at" json:"created_at"`
	UpdatedAt    pgtype.Timestamptz `db:"updated_at" json:"updated_at"`
	DeletedAt    pgtype.Timestamptz `db:"deleted_at" json:"deleted_at"`
}

type TripMembership struct {
	ID        string             `db:"id" json:"id"`
	TripID    string             `db:"trip_id" json:"trip_id"`
	UserID    string             `db:"user_id" json:"user_id"`
	Role      MembershipRole     `db:"role" json:"role"`
	Status    MembershipStatus   `db:"status" json:"status"`
	CreatedAt pgtype.Timestamp   `db:"created_at" json:"created_at"`
	UpdatedAt pgtype.Timestamp   `db:"updated_at" json:"updated_at"`
	DeletedAt pgtype.Timestamptz `db:"deleted_at" json:"deleted_at"`
}

type UserProfile struct {
	ID          string             `db:"id" json:"id"`
	Email       string             `db:"email" json:"email"`
	Username    string             `db:"username" json:"username"`
	FirstName   string             `db:"first_name" json:"first_name"`
	LastName    string             `db:"last_name" json:"last_name"`
	AvatarUrl   string             `db:"avatar_url" json:"avatar_url"`
	Preferences []byte             `db:"preferences" json:"preferences"`
	CreatedAt   pgtype.Timestamptz `db:"created_at" json:"created_at"`
	UpdatedAt   pgtype.Timestamptz `db:"updated_at" json:"updated_at"`
}
