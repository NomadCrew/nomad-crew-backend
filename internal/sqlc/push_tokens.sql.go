// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: push_tokens.sql

package sqlc

import (
	"context"
)

const cleanupOldInactiveTokens = `-- name: CleanupOldInactiveTokens :exec
DELETE FROM user_push_tokens
WHERE is_active = false AND updated_at < NOW() - INTERVAL '30 days'
`

// Removes inactive tokens older than 30 days
func (q *Queries) CleanupOldInactiveTokens(ctx context.Context) error {
	_, err := q.db.Exec(ctx, cleanupOldInactiveTokens)
	return err
}

const countActiveTokens = `-- name: CountActiveTokens :one
SELECT COUNT(*) as count
FROM user_push_tokens
WHERE user_id = $1 AND is_active = true
`

// Counts active tokens for a user
func (q *Queries) CountActiveTokens(ctx context.Context, userID string) (int64, error) {
	row := q.db.QueryRow(ctx, countActiveTokens, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const deactivateAllUserTokens = `-- name: DeactivateAllUserTokens :exec
UPDATE user_push_tokens
SET is_active = false, updated_at = NOW()
WHERE user_id = $1
`

// Deactivates all tokens for a user (e.g., on account delete or forced logout)
func (q *Queries) DeactivateAllUserTokens(ctx context.Context, userID string) error {
	_, err := q.db.Exec(ctx, deactivateAllUserTokens, userID)
	return err
}

const deactivatePushToken = `-- name: DeactivatePushToken :exec
UPDATE user_push_tokens
SET is_active = false, updated_at = NOW()
WHERE user_id = $1 AND token = $2
`

type DeactivatePushTokenParams struct {
	UserID string `db:"user_id" json:"user_id"`
	Token  string `db:"token" json:"token"`
}

// Deactivates a specific token (e.g., on logout)
func (q *Queries) DeactivatePushToken(ctx context.Context, arg DeactivatePushTokenParams) error {
	_, err := q.db.Exec(ctx, deactivatePushToken, arg.UserID, arg.Token)
	return err
}

const getActiveTokensForUser = `-- name: GetActiveTokensForUser :many
SELECT id, user_id, token, device_type, is_active, created_at, updated_at, last_used_at
FROM user_push_tokens
WHERE user_id = $1 AND is_active = true
ORDER BY last_used_at DESC NULLS LAST
`

// Gets all active push tokens for a user
func (q *Queries) GetActiveTokensForUser(ctx context.Context, userID string) ([]*UserPushToken, error) {
	rows, err := q.db.Query(ctx, getActiveTokensForUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*UserPushToken{}
	for rows.Next() {
		var i UserPushToken
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Token,
			&i.DeviceType,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.LastUsedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getActiveTokensForUsers = `-- name: GetActiveTokensForUsers :many
SELECT id, user_id, token, device_type, is_active, created_at, updated_at, last_used_at
FROM user_push_tokens
WHERE user_id = ANY($1::uuid[]) AND is_active = true
`

// Gets all active push tokens for multiple users (for batch sending)
func (q *Queries) GetActiveTokensForUsers(ctx context.Context, dollar_1 []string) ([]*UserPushToken, error) {
	rows, err := q.db.Query(ctx, getActiveTokensForUsers, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*UserPushToken{}
	for rows.Next() {
		var i UserPushToken
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Token,
			&i.DeviceType,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.LastUsedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const invalidateToken = `-- name: InvalidateToken :exec
UPDATE user_push_tokens
SET is_active = false, updated_at = NOW()
WHERE token = $1
`

// Marks a token as invalid (e.g., when Expo reports it as invalid)
func (q *Queries) InvalidateToken(ctx context.Context, token string) error {
	_, err := q.db.Exec(ctx, invalidateToken, token)
	return err
}

const registerPushToken = `-- name: RegisterPushToken :one

INSERT INTO user_push_tokens (user_id, token, device_type, is_active, last_used_at)
VALUES ($1, $2, $3, true, NOW())
ON CONFLICT (user_id, token) DO UPDATE SET
    is_active = true,
    device_type = EXCLUDED.device_type,
    updated_at = NOW(),
    last_used_at = NOW()
RETURNING id, user_id, token, device_type, is_active, created_at, updated_at, last_used_at
`

type RegisterPushTokenParams struct {
	UserID     string `db:"user_id" json:"user_id"`
	Token      string `db:"token" json:"token"`
	DeviceType string `db:"device_type" json:"device_type"`
}

// Push Token Operations
// Upserts a push token for a user (updates if already exists)
func (q *Queries) RegisterPushToken(ctx context.Context, arg RegisterPushTokenParams) (*UserPushToken, error) {
	row := q.db.QueryRow(ctx, registerPushToken, arg.UserID, arg.Token, arg.DeviceType)
	var i UserPushToken
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Token,
		&i.DeviceType,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LastUsedAt,
	)
	return &i, err
}

const updateTokenLastUsed = `-- name: UpdateTokenLastUsed :exec
UPDATE user_push_tokens
SET last_used_at = NOW()
WHERE token = $1 AND is_active = true
`

// Updates the last_used_at timestamp for a token
func (q *Queries) UpdateTokenLastUsed(ctx context.Context, token string) error {
	_, err := q.db.Exec(ctx, updateTokenLastUsed, token)
	return err
}
